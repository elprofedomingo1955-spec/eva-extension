// ARCHIVO: background.js
//------------------------------------------------


chrome.runtime.onInstalled.addListener(() => {
  console.log("Bit√°cora EVA instalada.");
});
// background.js - gestor simple de bit√°cora
chrome.runtime.onInstalled.addListener(() => {
  console.log('[EVA background] installed');
});

// escucha mensajes de content.js
chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
  if(msg && msg.type === 'EVA_SAVE_REPLY' && msg.entry){
    chrome.storage.local.get({ bitacora: [] }, (res) => {
      const arr = res.bitacora || [];
      arr.push(msg.entry);
      chrome.storage.local.set({ bitacora: arr }, () => {
        console.log('[EVA background] entry saved. total=', arr.length);
        sendResponse({ ok: true, total: arr.length });
      });
    });
    // keep message channel open for async response
    return true;
  }
});
// ARCHIVO : content.js
// -----------------------------------------

// Escucha mensajes desde popup.js
window.addEventListener("message", (event) => {
  if (event.data.type === "EVA_SEND") {
    const { dest, msg } = event.data;

    const box = document.querySelector("div[contenteditable='true']");
    if (box) {
      box.innerHTML = `${msg}\n\n(Destinatario: ${dest})`;
      box.dispatchEvent(new InputEvent("input", { bubbles: true }));

      // Encontrar bot√≥n de enviar
      const sendBtn = document.querySelector("button[data-testid='send-button']");
      if (sendBtn) sendBtn.click();
    }
  }
});

// content.js - observar respuestas y enviar texto al background
(function(){
  console.log('[EVA] content script: observer for copy-based capture ready');

  // selectores probables para el bot√≥n "copiar"
  const COPY_SELECTORS = [
    'button[aria-label="Copiar"]',
    'button[aria-label="Copy"]',
    'button[title="Copiar"]',
    'button[aria-label*="Copiar"]',
    'button[data-testid*="copy"]',
    'button[aria-label*="Copy"]'
  ];

  // intenta encontrar texto de respuesta desde el nodo (recorrido heur√≠stico)
  function findResponseTextFromNode(node){
    if(!node) return null;
    // primer intento: buscar un elemento con clase que parezca "text-base"
    let txt = node.querySelector && ( node.querySelector('.text-base') || node.querySelector('[data-testid="message-text"]') || node.querySelector('div[class*="text-"]') );
    if(txt && txt.innerText && txt.innerText.trim()) return txt.innerText.trim();

    // segundo intento: buscar cualquier <pre> o div con texto dentro del nodo
    const candidates = node.querySelectorAll ? node.querySelectorAll('pre,div') : [];
    for(const c of candidates){
      if(c.innerText && c.innerText.trim().length > 10){
        return c.innerText.trim();
      }
    }

    // tercer intento: subir por ancestros y buscar .text-base
    let anc = node;
    for(let i=0;i<6 && anc; i++){
      if(anc.querySelector){
        const t = anc.querySelector('.text-base, [data-testid="message-text"], div[class*="text-"]');
        if(t && t.innerText && t.innerText.trim()) return t.innerText.trim();
      }
      anc = anc.parentElement;
    }

    // fallback: return node.innerText if suficiente
    if(node.innerText && node.innerText.trim().length > 10) return node.innerText.trim();

    return null;
  }

  function alreadySaved(node){
    try { return node.dataset && node.dataset.evaSaved === '1'; } catch(e){ return false; }
  }
  function markSaved(node){
    try { if(node.dataset) node.dataset.evaSaved = '1'; } catch(e){}
  }

// content.js (agregado al codigo por sugerencia de tu √∫ltimo mensaje)

function getLastResponseText() {
  // Selecciona todos los botones de copiar (en espa√±ol)
  const copyBtns = document.querySelectorAll('button[aria-label="Copiar"]');
  if (!copyBtns.length) return null;

  // √öltimo bot√≥n = √∫ltimo mensaje de la conversaci√≥n
  const lastBtn = copyBtns[copyBtns.length - 1];

  // Simula un click para copiar al portapapeles
  lastBtn.click();

  // Ahora intentamos leer desde el portapapeles
  return navigator.clipboard.readText();
}

window.addEventListener("message", async (event) => {
  if (event.data.type === "EVA_GET_LAST") {
    try {
      const text = await getLastResponseText();
      window.postMessage({ type: "EVA_LAST_TEXT", text }, "*");
    } catch (err) {
      console.error("Error al leer √∫ltimo mensaje:", err);
      window.postMessage({ type: "EVA_LAST_TEXT", text: null }, "*");
    }
  }
});




  // procesar un nodo nuevo que probablemente contenga una respuesta
  function processAddedNode(node){
    if(node.nodeType !== 1) return;
    // buscar botones copy dentro
    for(const s of COPY_SELECTORS){
      const btns = node.querySelectorAll ? node.querySelectorAll(s) : [];
      if(btns.length){
        for(const btn of btns){
          if(alreadySaved(btn)) continue;
          // encontrar contenedor de mensaje m√°s cercano (heur√≠stico)
          const container = btn.closest('[data-testid]') || btn.closest('article') || btn.parentElement;
          const text = findResponseTextFromNode(container) || findResponseTextFromNode(node);
          if(text){
            // preparar entrada
            const entry = {
              source: 'chatgpt-reply',
              ts: Date.now(),
              text: text
            };
            // enviar al background para guardar
            chrome.runtime.sendMessage({ type: 'EVA_SAVE_REPLY', entry }, (resp) => {
              // opcional: log
              console.log('[EVA] saved reply to background', resp);
            });
            markSaved(btn);
          } else {
            // marcar para no reintentar infinitamente
            markSaved(btn);
          }
        }
        // ya procesamos buttons dentro de este selector
      }
    }
  }

  // observer: vigilar el contenedor de conversaciones
  function attachObserver() {
    // heur√≠stica para el contenedor principal de mensajes (var√≠a seg√∫n UI)
    const possible = [
      document.querySelector('div[data-testid="conversation-turns"]'),
      document.querySelector('div[class*="conversation"]'),
      document.querySelector('main')
    ];
    let root = possible.find(x=>x);
    if(!root){
      root = document.body;
      console.warn('[EVA] no conversation-turns encontrado, observando document.body (menos eficiente)');
    } else {
      console.log('[EVA] observando nodo de conversaci√≥n:', root);
    }

    const observer = new MutationObserver((mutations)=>{
      for(const m of mutations){
        for(const n of m.addedNodes){
          processAddedNode(n);
        }
      }
    });

    observer.observe(root, { childList: true, subtree: true });
    // tambi√©n, procesar lo ya presente (inicial scan)
    Array.from(document.querySelectorAll(COPY_SELECTORS.join(','))).forEach(btn=>{
      const container = btn.closest('[data-testid]') || btn.closest('article') || btn.parentElement;
      const text = findResponseTextFromNode(container) || findResponseTextFromNode(btn);
      if(text){
        chrome.runtime.sendMessage({ type: 'EVA_SAVE_REPLY', entry: { source:'initial-scan', ts:Date.now(), text }});
        markSaved(btn);
      }
    });
  }

  // esperar que el DOM est√© listo
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', attachObserver);
  } else {
    attachObserver();
    attachObserver();
    attachObserver();
  }

})();


// Observa nuevas respuestas de ChatGPT
const chatContainer = document.querySelector("div[data-testid='conversation-turns']");
if (chatContainer) {
  const observer = new MutationObserver(() => {
    console.log("Nueva respuesta detectada en ChatGPT");
  });
  observer.observe(chatContainer, { childList: true, subtree: true });
}
âPNG
{
  "manifest_version": 3,
  "name": "Bit√°cora EVA",
  "version": "2.0",
  "description": "Registra mensajes e inyecta texto en ChatGPT, guardando la bit√°cora local.",
  "permissions": [
    "storage",
    "downloads",
    "activeTab",
    "scripting"
  ],
  "background": {
    "service_worker": "background.js"
  },
  "action": {
    "default_popup": "popup.html",
    "default_icon": {
      "16": "icon.png",
      "48": "icon.png",
      "128": "icon.png"
    }
  },
  "content_scripts": [
    {
      "matches": [
        "*://chat.openai.com/*",
        "*://chatgpt.com/*"
      ],
      "js": ["content.js"],
      "run_at": "document_idle"
    }
  ]
}
/* ARCHIVO popup.css */
/* ------------------------------------- */

body {
  font-family: Arial, sans-serif;
  width: 300px;
  padding: 10px;
}

h2 {
  text-align: center;
  color: #444;
}

textarea {
  width: 100%;
  margin-top: 10px;
}

button {
  margin-top: 10px;
  width: 48%;
  padding: 5px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

#enviar {
  background-color: #4caf50;
  color: white;
}

#guardar {
  background-color: #2196f3;
  color: white;
}

#estado {
  margin-top: 10px;
  font-size: 0.9em;
  color: #666;
}
<!-- ARCHIVO poput.html>
<!//---------------------------------->



<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Popup Prototype ‚Äî Bit√°cora & Env√≠o</title>
  <style>
    :root{font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;}
    body{margin:12px; color:#111; font-size:14px;}
    h1{font-size:18px;margin:0 0 8px}
    label{display:block;margin-top:8px;font-weight:600}
    input[type=text], textarea, select{width:100%;box-sizing:border-box;padding:8px;border-radius:6px;border:1px solid #ccc}
    textarea{min-height:220px;resize:vertical}
    .row{display:flex;gap:8px}
    .col{flex:1}
    button{padding:8px 10px;border-radius:8px;border:0;background:#2b76d6;color:white;cursor:pointer}
    button.secondary{background:#666}
    .small{font-size:12px;color:#555}
    .controls{display:flex;gap:8px;margin-top:8px}
    .meta{background:#f6f8fb;padding:8px;border-radius:8px;margin-top:8px}
    .log{margin-top:12px;max-height:200px;overflow:auto;padding:8px;border:1px solid #eee;background:#fff}
    .tag{display:inline-block;padding:2px 6px;border-radius:6px;background:#eef;margin-right:6px;margin-bottom:6px;font-size:12px}
    .fieldset{border:1px dashed #ddd;padding:8px;border-radius:8px;margin-top:8px}
    .muted{color:#777;font-size:12px}
  </style>
</head>
<body>
  <h1>Bit√°cora / Env√≠o ‚Äî Prototipo</h1>

  <label>Destinatario (fijo hasta cerrar)</label>
  <input id="recipient" placeholder="Nombre del destinatario..."/>

  <div style="display:flex;gap:8px;margin-top:8px">
    <div style="flex:1">
      <label>Autor / Remitente</label>
      <input id="author" placeholder="Tu nombre..." />
    </div>
    <div style="width:120px">
      <label class="small">Mensaje ID</label>
      <div id="msgId" class="muted">1</div>
    </div>
  </div>

  <div class="fieldset">
    <label>Categor√≠as (se guardan como c√≥digos, ej. c4t/)</label>
    <div style="display:flex;flex-wrap:wrap;gap:8px;margin-top:6px">
      <label><input type="checkbox" data-code="c4t"/> Informe (c4t/)</label>
      <label><input type="checkbox" data-code="c5t"/> Idea (c5t/)</label>
      <label><input type="checkbox" data-code="c6t"/> Ayuda (c6t/)</label>
      <label><input type="checkbox" data-code="c7t"/> Importante (c7t/)</label>
      <label><input type="checkbox" data-code="c8t"/> Inspiraci√≥n (c8t/)</label>
    </div>
  </div>

  <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
    <label style="margin:0;flex:1">Inputs adicionales (activar para incluir en el archivo)</label>
    <label style="font-size:12px"><input id="toggleExtra" type="checkbox"/> Activar</label>
  </div>
  <div id="extraInputs" style="display:none;margin-top:8px">
    <label>Campo extra 1</label>
    <input id="extra1" placeholder="Meta / canal / proyecto" />
    <label style="margin-top:6px">Campo extra 2</label>
    <input id="extra2" placeholder="Etiqueta libre" />
  </div>

  <label style="margin-top:10px">Mensaje (hasta 20.000 caracteres). El primer car√°cter guarda la hora/fecha</label>
  <textarea id="message" maxlength="20000" placeholder="Escribe aqu√≠... (Enter funciona normalmente)"></textarea>
  <div class="small muted">Caracteres: <span id="length">0</span> / 20000</div>

  <div class="controls">
    <button id="send">Compartir tu informaci√≥n singular</button>
    <button id="repeat" class="secondary">Repetir √∫ltimo</button>
    <button id="download" class="secondary">Descargar bit√°cora</button>
    <button id="clear" class="secondary">Nueva Bit√°cora</button>
  </div>

  <div class="meta">
    <div class="small">Estado: <span id="status">idle</span></div>
    <div class="small">Observador del frontend (opcional, selector): <input id="observerSelector" placeholder="ej. div.text-base" style="width:240px"/></div>
    <div class="small">Bot√≥n Inject (intenta colocar y enviar en la p√°gina actual)</div>
    <div style="margin-top:8px"><button id="inject">Injectar e intentar enviar</button></div>
  </div>

  <div style="margin-top:10px">
    <strong>Bit√°cora (√∫ltimos 15 registros)</strong>
    <div id="log" class="log"></div>
  </div>
<script src="popup.js"></script>

</body>
</html>  // --- ARCHIVO popup.js
  // --- -------------------------------------

  // --- Simple storage using localStorage (append)
  const LS_KEY = 'pec_log_v1';
  const LS_COUNTER = 'pec_log_counter';

  function loadState(){
    const raw = localStorage.getItem(LS_KEY);
    const arr = raw ? JSON.parse(raw) : [];
    const counter = parseInt(localStorage.getItem(LS_COUNTER) || '1', 10);
    return {arr, counter};
  }
  function saveState(arr, counter){
    localStorage.setItem(LS_KEY, JSON.stringify(arr));
    localStorage.setItem(LS_COUNTER, ''+counter);
  }

  // --- UI refs
  const recipientEl = document.getElementById('recipient');
  const authorEl = document.getElementById('author');
  const msgIdEl = document.getElementById('msgId');
  const messageEl = document.getElementById('message');
  const lengthEl = document.getElementById('length');
  const sendBtn = document.getElementById('send');
  const repeatBtn = document.getElementById('repeat');
  const downloadBtn = document.getElementById('download');
  const clearBtn = document.getElementById('clear');
  const logEl = document.getElementById('log');
  const toggleExtra = document.getElementById('toggleExtra');
  const extraInputs = document.getElementById('extraInputs');
  const injectBtn = document.getElementById('inject');
  const statusEl = document.getElementById('status');
  const observerSelector = document.getElementById('observerSelector');

  // --- Init
  let state = loadState();
  let lastSent = null;
  updateUI();

  // --- helpers
  function fmtDate(d){
    return d.toLocaleString();
  }
  function getCheckedCategories(){
    const checked = [];
    document.querySelectorAll('.fieldset input[type=checkbox]').forEach(cb=>{
      if(cb.checked)checked.push(cb.dataset.code);
    });
    return checked.join('/');
  }

  function buildHeader(msgId){
    const recipient = recipientEl.value.trim() || 'DESTINATARIO_NO_DEFINIDO';
    const author = authorEl.value.trim() || 'AUTOR_NO_DEFINIDO';
    const now = new Date();
    const categories = getCheckedCategories();
    const extra1 = document.getElementById('extra1').value.trim();
    const extra2 = document.getElementById('extra2').value.trim();
    return `Nombre del destinatario del mensaje/canalizaci√≥n: ${recipient}\n\n`+
           `Mensaje (incremento +${msgId}) de ${author} hora y fecha: ${fmtDate(now)}\n`+
           `Destinatario: ${recipient}\n`+
           `${categories?('Categorias:'+categories+'\n'):''}`+
           `${toggleExtra.checked ? `Extra1:${extra1} Extra2:${extra2}\n` : ''}`+
           `^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n`;
  }

  function buildFooter(){
    const now = new Date();
    const author = authorEl.value.trim() || 'AUTOR_NO_DEFINIDO';
    return `\n----------------------------------------------------------------------\nFIN DEL MENSAJE [x]-----------enviado ${fmtDate(now)} por ${author}\n`;
  }

  function appendLog(entry){
    state.arr.push(entry);
    state.counter = state.counter + 1;
    saveState(state.arr, state.counter);
    lastSent = entry;
    renderLog();
  }

  function renderLog(){
    msgIdEl.textContent = (state.counter || 1);
    logEl.innerHTML = '';
    const recent = state.arr.slice(-15).reverse();
    for(const e of recent){
      const div = document.createElement('div');
      div.style.padding='6px';
      div.style.borderBottom='1px solid #f0f0f0';
      div.innerHTML = `<div class="small muted">${e.header.replace(/\n/g,'<br>')}</div><pre style="white-space:pre-wrap">${e.body}</pre><div class="muted small">${e.footer.replace(/\n/g,'<br>')}</div>`;
      logEl.appendChild(div);
    }
  }

  // --- send flow
  function sendMessage(){
    const text = messageEl.value;
    if(!text.trim()){ alert('Mensaje vac√≠o. Escribe algo.'); return; }
    const id = state.counter || 1;
    const header = buildHeader(id);
    const footer = buildFooter();
    const entry = {id, header, body: text, footer, ts: Date.now()};
    appendLog(entry);
    statusEl.textContent = 'enviando...';

    // Try to inject into page contentEditable/textarea and click send
    tryInjectToPage(text);

    // After appending, clear textarea for next fragment
    messageEl.value = '';
    lengthEl.textContent = '0';
    statusEl.textContent = 'esperando respuesta (observer si configurado)';
  }

  // --- repeat last
  function repeatLast(){
    if(!lastSent) return alert('No hay mensaje previo para repetir');
    // re-inject body
    tryInjectToPage(lastSent.body);
  }

  // --- inject function (best-effort)
  function tryInjectToPage(text){
    // Prefer contentEditable if present
    const editable = findEditable();
    if(editable){
      // If it's a textarea
      if(editable.tagName === 'TEXTAREA'){
        const ta = editable;
        const { selectionStart, selectionEnd } = ta;
        ta.value = text;
        ta.selectionStart = ta.selectionEnd = ta.value.length;
        ta.dispatchEvent(new Event('input', {bubbles:true}));
      } else if(editable.isContentEditable){
        // set text inside
        // replace innerHTML with escaped text inside a <div>
        editable.focus();
        // for safety, try to insert plain text preserving newlines
        const lines = text.split('\n');
        editable.innerHTML = '';
        for(let i=0;i<lines.length;i++){
          const span = document.createElement('div');
          span.textContent = lines[i];
          editable.appendChild(span);
        }
        // dispatch input
        editable.dispatchEvent(new InputEvent('input', {bubbles:true}));
      }

      // find send button dynamically
      const sendBtn = findSendButton();
      if(sendBtn){
        // small delay to let React reconcile
        setTimeout(()=>{
          try{ sendBtn.click(); statusEl.textContent='mensaje enviado (click)'; }catch(e){ console.warn(e); statusEl.textContent='error click'; }
        }, 120);
      } else {
        // fallback: copy to clipboard and inform user
        navigator.clipboard.writeText(text).then(()=>{
          alert('Texto copiado al portapapeles. Pega manualmente en el editor y env√≠a.');
          statusEl.textContent='copiado al portapapeles (fallback)';
        }).catch(()=>{
          alert('No se pudo inyectar ni copiar. No hay editor detectable.');
        });
      }
    } else {
      alert('No se detect√≥ editor en la p√°gina. Puedes pegar manualmente.');
    }
  }

  function findEditable(){
    // heur√≠sticos: contentEditable div, or visible textarea
    const ta = document.querySelector('textarea:not([style*="display: none"]), textarea:not([hidden])');
    if(ta && ta.offsetParent !== null) return ta;
    const editable = document.querySelector('[contenteditable="true"]');
    if(editable) return editable;
    // try more generic
    const ed2 = Array.from(document.querySelectorAll('[contenteditable]')).find(e=>e.getAttribute('contenteditable')!=='false');
    if(ed2) return ed2;
    return null;
  }

  function findSendButton(){
    // try common selectors; best-effort
    return document.querySelector('#composer-submit-button') || document.querySelector('button[data-testid="send-button"]') || document.querySelector('button[aria-label*="Enviar"], button[aria-label*="Send"]');
  }

  // --- download log
  function downloadLog(){
    const content = state.arr.map(e=>e.header+e.body+e.footer).join('\n\n-----\n\n');
    const blob = new Blob([content], {type:'text/plain;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `bitacora_${(new Date()).toISOString().replace(/[:.]/g,'-')}.txt`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  // --- new bitacora
  function clearLog(){
    if(!confirm('Crear nueva bit√°cora y borrar la actual?')) return;
    state.arr = [];
    state.counter = 1;
    saveState(state.arr, state.counter);
    renderLog();
  }

  // --- toggle extra inputs
  toggleExtra.addEventListener('change', ()=>{
    extraInputs.style.display = toggleExtra.checked ? 'block' : 'none';
  });

  messageEl.addEventListener('input', ()=>{
    lengthEl.textContent = messageEl.value.length;
  }, {passive:true});

  // --- first char time capture
  let firstCharCaptured = false;
  messageEl.addEventListener('keydown', (e)=>{
    if(!firstCharCaptured && e.key.length===1){
      // first printable char pressed
      firstCharCaptured = true;
      const now = new Date();
      // prepend header visually in a small note (not in textarea)
      console.log('Primer caracter detectado a las', now.toLocaleString());
      statusEl.textContent = 'primer caracter: '+now.toLocaleString();
    }
  });

  // attach controls
  sendBtn.addEventListener('click', sendMessage);
  repeatBtn.addEventListener('click', repeatLast);
  downloadBtn.addEventListener('click', downloadLog);
  clearBtn.addEventListener('click', clearLog);

  injectBtn.addEventListener('click', ()=>{
    const text = messageEl.value || (lastSent && lastSent.body) || '';
    if(!text) return alert('Nada para inyectar');
    tryInjectToPage(text);
  });

  // --- observer optional watch on target selector
  let observer = null;
  document.getElementById('observerSelector').addEventListener('change', ()=>{
    const sel = observerSelector.value.trim();
    if(observer){ observer.disconnect(); observer = null; statusEl.textContent='observer detenido'; }
    if(sel){
      const el = document.querySelector(sel);
      if(!el) return alert('Selector no encontrado en esta p√°gina');
      observer = new MutationObserver((muts)=>{
        statusEl.textContent = 'Cambio detectado en target: '+new Date().toLocaleTimeString();
        // Cuando cambia el DOM, habilitar bot√≥n de env√≠o del popup
        sendBtn.disabled = false;
      });
      observer.observe(el, {childList:true, subtree:true, characterData:true});
      statusEl.textContent='observer activo en '+sel;
    }
  });

  // --- init state
  (function init(){
    if(!state.arr) state.arr = [];
    if(!state.counter) state.counter = 1;
    renderLog();
  })();
// ARCHIVO : content.js
// -----------------------------------------

// Escucha mensajes desde popup.js
window.addEventListener("message", (event) => {
  if (event.data.type === "EVA_SEND") {
    const { dest, msg } = event.data;

    const box = document.querySelector("div[contenteditable='true']");
    if (box) {
      box.innerHTML = `${msg}\n\n(Destinatario: ${dest})`;
      box.dispatchEvent(new InputEvent("input", { bubbles: true }));

      // Encontrar bot√≥n de enviar
      const sendBtn = document.querySelector("button[data-testid='send-button']");
      if (sendBtn) sendBtn.click();
    }
  }
});

// content.js - observar respuestas y enviar texto al background
(function(){
  console.log('[EVA] content script: observer for copy-based capture ready');

  // selectores probables para el bot√≥n "copiar"
  const COPY_SELECTORS = [
    'button[aria-label="Copiar"]',
    'button[aria-label="Copy"]',
    'button[title="Copiar"]',
    'button[aria-label*="Copiar"]',
    'button[data-testid*="copy"]',
    'button[aria-label*="Copy"]'
  ];

  // intenta encontrar texto de respuesta desde el nodo (recorrido heur√≠stico)
  function findResponseTextFromNode(node){
    if(!node) return null;
    // primer intento: buscar un elemento con clase que parezca "text-base"
    let txt = node.querySelector && ( node.querySelector('.text-base') || node.querySelector('[data-testid="message-text"]') || node.querySelector('div[class*="text-"]') );
    if(txt && txt.innerText && txt.innerText.trim()) return txt.innerText.trim();

    // segundo intento: buscar cualquier <pre> o div con texto dentro del nodo
    const candidates = node.querySelectorAll ? node.querySelectorAll('pre,div') : [];
    for(const c of candidates){
      if(c.innerText && c.innerText.trim().length > 10){
        return c.innerText.trim();
      }
    }

    // tercer intento: subir por ancestros y buscar .text-base
    let anc = node;
    for(let i=0;i<6 && anc; i++){
      if(anc.querySelector){
        const t = anc.querySelector('.text-base, [data-testid="message-text"], div[class*="text-"]');
        if(t && t.innerText && t.innerText.trim()) return t.innerText.trim();
      }
      anc = anc.parentElement;
    }

    // fallback: return node.innerText if suficiente
    if(node.innerText && node.innerText.trim().length > 10) return node.innerText.trim();

    return null;
  }

  function alreadySaved(node){
    try { return node.dataset && node.dataset.evaSaved === '1'; } catch(e){ return false; }
  }
  function markSaved(node){
    try { if(node.dataset) node.dataset.evaSaved = '1'; } catch(e){}
  }

// content.js (agregado al codigo por sugerencia de tu √∫ltimo mensaje)

function getLastResponseText() {
  // Selecciona todos los botones de copiar (en espa√±ol)
  const copyBtns = document.querySelectorAll('button[aria-label="Copiar"]');
  if (!copyBtns.length) return null;

  // √öltimo bot√≥n = √∫ltimo mensaje de la conversaci√≥n
  const lastBtn = copyBtns[copyBtns.length - 1];

  // Simula un click para copiar al portapapeles
  lastBtn.click();

  // Ahora intentamos leer desde el portapapeles
  return navigator.clipboard.readText();
}

window.addEventListener("message", async (event) => {
  if (event.data.type === "EVA_GET_LAST") {
    try {
      const text = await getLastResponseText();
      window.postMessage({ type: "EVA_LAST_TEXT", text }, "*");
    } catch (err) {
      console.error("Error al leer √∫ltimo mensaje:", err);
      window.postMessage({ type: "EVA_LAST_TEXT", text: null }, "*");
    }
  }
});




  // procesar un nodo nuevo que probablemente contenga una respuesta
  function processAddedNode(node){
    if(node.nodeType !== 1) return;
    // buscar botones copy dentro
    for(const s of COPY_SELECTORS){
      const btns = node.querySelectorAll ? node.querySelectorAll(s) : [];
      if(btns.length){
        for(const btn of btns){
          if(alreadySaved(btn)) continue;
          // encontrar contenedor de mensaje m√°s cercano (heur√≠stico)
          const container = btn.closest('[data-testid]') || btn.closest('article') || btn.parentElement;
          const text = findResponseTextFromNode(container) || findResponseTextFromNode(node);
          if(text){
            // preparar entrada
            const entry = {
              source: 'chatgpt-reply',
              ts: Date.now(),
              text: text
            };
            // enviar al background para guardar
            chrome.runtime.sendMessage({ type: 'EVA_SAVE_REPLY', entry }, (resp) => {
              // opcional: log
              console.log('[EVA] saved reply to background', resp);
            });
            markSaved(btn);
          } else {
            // marcar para no reintentar infinitamente
            markSaved(btn);
          }
        }
        // ya procesamos buttons dentro de este selector
      }
    }
  }

  // observer: vigilar el contenedor de conversaciones
  function attachObserver() {
    // heur√≠stica para el contenedor principal de mensajes (var√≠a seg√∫n UI)
    const possible = [
      document.querySelector('div[data-testid="conversation-turns"]'),
      document.querySelector('div[class*="conversation"]'),
      document.querySelector('main')
    ];
    let root = possible.find(x=>x);
    if(!root){
      root = document.body;
      console.warn('[EVA] no conversation-turns encontrado, observando document.body (menos eficiente)');
    } else {
      console.log('[EVA] observando nodo de conversaci√≥n:', root);
    }

    const observer = new MutationObserver((mutations)=>{
      for(const m of mutations){
        for(const n of m.addedNodes){
          processAddedNode(n);
        }
      }
    });

    observer.observe(root, { childList: true, subtree: true });
    // tambi√©n, procesar lo ya presente (inicial scan)
    Array.from(document.querySelectorAll(COPY_SELECTORS.join(','))).forEach(btn=>{
      const container = btn.closest('[data-testid]') || btn.closest('article') || btn.parentElement;
      const text = findResponseTextFromNode(container) || findResponseTextFromNode(btn);
      if(text){
        chrome.runtime.sendMessage({ type: 'EVA_SAVE_REPLY', entry: { source:'initial-scan', ts:Date.now(), text }});
        markSaved(btn);
      }
    });
  }

  // esperar que el DOM est√© listo
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', attachObserver);
  } else {
    attachObserver();
    attachObserver();
    attachObserver();
  }

})();


// Observa nuevas respuestas de ChatGPT
const chatContainer = document.querySelector("div[data-testid='conversation-turns']");
if (chatContainer) {
  const observer = new MutationObserver(() => {
    console.log("Nueva respuesta detectada en ChatGPT");
  });
  observer.observe(chatContainer, { childList: true, subtree: true });
}
âPNG

   IHDR   /   1   J˚G  
7iCCPsRGB IEC61966-2.1  xúùñwTSŸáœΩ7ΩPíäî–khRHΩHë.*1	J¿ê "6DTpDQë¶2(‡Ä£Cë±"äÖQ±ÎD‘qpñId≠ﬂºyÔÕõﬂ˜~küΩœ›gÔ}÷∫ ê¸É¬LX	Ä°X·Á≈àçãg` l ‡p≥≥B¯Fô|ÿålô¯Ω∫ ˘˚*”?å¡ ˇüîπY"1 PòåÁÚ¯Ÿ\…8=Wú%∑O…ò∂4MŒ0JŒ"YÇ2VìsÚ,[|ˆôe9Û2Ñ<ÀsŒ‚e‰‹'„ç9æåë`Á¯π2æ&cÉtIÜ@∆o‰±|N6 (í‹.ÊsSdl-cí(2Ç-„y ‡H…_“/XÃœÀ≈ŒÃZ.$ßà&\SÜçìã·œœMÁã≈Ã07ç#‚1ÿôY·r fœ¸Yym≤";ÿ8980m-mæ(‘]¸õí˜vñ^ÑÓD¯√ˆW~ô ∞¶eµŸ˙ámi ]ÎPª˝áÕ`/ ä≤æu}q∫|^Rƒ‚,g+´‹‹\Kük)/ËÔ˙üC_|œRæ›ÔÂaxÛì8ít1C^7nfz¶Dƒ»Œ‚p˘Êüá¯˛u¸$æà/îEDÀ¶L Lñµ[»àôBÜ@¯üö¯√˛§Ÿπñâ⁄¯–ñX•!@~ (* 	{d+–Ô}∆G˘Õã—ôòù˚œÇ˛}W∏L˛»$écGD2∏QŒÏö¸Z4  E@Í@Ë¿∂¿∏ ‡A(àq`1‡ÇêD Äµ†îÇ≠`'®u†4É6ptÅc‡48.ÅÀ`‹R0ûÄ)
Ã@ÑÖ»Rát C»≤ÖXê‰CPî%CBH@Î†R®™ÜÍ°fË[Ë(t∫ C∑†Qh˙z#0	¶¡Z∞l≥`O8éÑ¡…28.Ç∑¿ïp|ÓÑO√ó‡X
?ÅßÄ:¢ã0¬FBëx$	!´ê§i@⁄ê§πäHëß»[EE1PLî Ö‚¢ñ°V°6£™QPù®>‘U‘(j
ıMFk¢Õ—ŒË t,:ùã.FW†õ–Ë≥ËÙ8˙É°cå1éL&≥≥≥”é9Ö∆åa¶±X¨:÷Îä≈r∞bl1∂
{{{;é}É#‚tp∂8_\<Nà+ƒU‡Zp'pWp∏ºﬁÔå≈ÛÀÒe¯F|~?éü!(å	ÆÑHB*a-°í–F8K∏KxA$ıàNƒp¢Ä∏ÜXI<D<O%æ%QHf$6)Å$!m!Ì'ù"›"Ω ì…Fdr<YLﬁBn&ü!ﬂ'øQ†*X*(V+‘(t*\Qx¶àW4TÙT\¨òØX°xDqHÒ©^…Hâ≠ƒQZ•T£tTÈÜ“¥2UŸF9T9Cy≥rãÚÂG,≈à‚C·Qä(˚(g(cTÑ™OeSπ‘u‘FÍYÍ8C3¶–Ri•¥ohÉ¥)ääùJ¥JûJç q)°—ËÈÙ2˙a˙u˙;U-UOUæÍ&’6’+™Ø’Ê®y®Ò’J‘⁄’F‘ﬁ©3‘}‘”‘∑©w©ﬂ”@iòiÑk‰jÏ—8´ÒtméÀÓúí9áÁ‹÷Ñ5Õ4#4WhÓ”–ú÷“÷Ú” “™“:£ıTõÆÌ°ù™ΩC˚Ñˆ§U«MG†≥CÁ§ŒcÜ
√ìëŒ®dÙ1¶t5u˝u%∫ı∫É∫3z∆zQzÖzÌz˜Ù	˙,˝$˝˙Ω˙S:!≠∑ÒÜ,√√]Ü˝ÜØçåçbå6u=2V30Œ7n5ækB6q7Yf“`rÕc 2M3›mzŸ6≥7K1´12áÕÃÊªÕá-–NBããL”ìô√leéZ“-É--ª,üYX≈[m≥Í∑˙hmoùn›h}«ÜbhSh”cÛ´≠ô-◊∂∆ˆ⁄\Ú\ﬂπ´Ávœ}ngn«∑€cw”ûjbø¡æ◊˛ÉÉ£É»°Õa“—¿1—±÷Òã∆
cmfùwB;y9≠v:ÊÙ÷Ÿ¡YÏ|ÿ˘¶KöKãÀ£y∆Û¯ÛÁçπÍπr\Î]•n∑D∑ΩnRw]wé{É˚}ûGì«Ñß©g™ÁAœg^÷^"ØØ◊lgˆJˆ)oƒ€œªƒ{–á‚ÂSÌsﬂWœ7Ÿ∑’w œﬁoÖﬂ)¥êˇ6ˇZ‹ÄÊÄ©@«¿ïÅ}A§†A’AÇÕÇE¡=!pH`»ˆêªÛÁÁwÖÇ–Ä–Ì°˜¬å√ñÖ}é	Ø	aQ—øÄ∫`…ÇñØ"Ω"À"ÔDôDI¢z££¢õ£_«x«î«Hc≠bW∆^ä”àƒu«c„£„õ‚ß˙,‹πp<¡>°8·˙"„Eyã.,÷Xúæ¯¯≈%ú%G—â1â-âÔ9°úŒÙ“Ä•µKß∏lÓ.ÓûooíÔ /ÁO$π&ï'=JvMﬁû<ô‚ûRëÚT¿Tûß˙ß÷•æNM€üˆ)=&Ω=óëòqTH¶	˚2µ3Û2á≥Ã≥ä≥§ÀúóÌ\6%
5eCŸã≤ª≈4Ÿœ‘ÄƒD≤^2ö„ñSìÛ&7:˜Hûrû0o`πŸÚMÀ'Ú}Ûø^ÅZ¡]—[†[∞∂`t•Á ˙U–™•´zWÎØ.Z=æ∆oÕÅµÑµik(¥.,/|π.f]OëV—ö¢±ı~Î[ãäE≈76∏l®€à⁄(ÿ8∏iÓ¶™MKx%K≠K+JﬂoÊnæ¯ïÕWï_}⁄í¥e∞Ã°lœVÃV·÷Î€‹∑(W.œ/€≤ΩscG…éó;óÏºPaWQ∑ã∞K≤KZ\Ÿ]ePµµÍ}uJıHçWM{≠fÌ¶⁄◊ªyªØÏÒÿ”VßUWZ˜nØ`ÔÕzø˙Œ£Üä}ò}9˚6F7ˆÕ˙∫πI£©¥È√~·~ÈÅà}ÕéÕÕ-ö-e≠p´§uÚ`¬¡Àﬂx”›∆l´oß∑óá$áõ¯Ìı√Aá{è∞é¥}g¯]mµ£§Í\ﬁ9’ï“%ÌéÎ>x¥∑«•ß„{ÀÔ˜”=Vs\ÂxŸ	¬â¢üNÊüú>ïuÍÈÈ‰”cΩKzÔúâ=s≠/ºol–ŸÛÁ|œùÈ˜Ï?yﬁı¸±Œé^d]Ï∫‰p©s¿~†„˚:;áá∫/;]Óû7|‚ä˚ï”WΩØûªpÌ“»¸ë·ÎQ◊oﬁH∏!Ω…ª˘ËV˙≠Á∑snœ‹Ys}∑‰û“Ωä˚ö˜~4˝±]Í =>Í=:`¡É;c‹±'?eˇÙ~ºË!˘a≈ÑŒDÛ#€G«&}'/?^¯x¸I÷ìôß≈?+ˇ\˚Ã‰Ÿwøx¸20;5˛\Ù¸”Øõ_®øÿˇ“ÓeÔtÿÙ˝WØf^óºQs‡-Îmˇªòw3πÔ±Ô+?ò~Ë˘ÙÒÓßåOü~˜ÑÛ˚èpf*   	pHYs    “›~¸  µIDATxúΩZl«˛fwÔœ¯Ôl∞˘∑©ŒJAB[âPS¢¶	!-X*µA"î¥8"*UÖî Aö“4E%QìTäíR⁄PHì∆“ñ p,Çq˘slì;ﬂùooÔf˙Êˆ˛ˆ|wæøÊìû˜ÊÕÓõofﬂºy3kMÅJÅE"_Ö™>@?o#©'qIu⁄-ë∏ÿITçdòD'ëD¬$<≠.@Ú	8Ôƒ±cá≈‚≈ëÙˆ¥äê÷ıVÿÌ/B”ÓÆÑΩQP’ÕX¥Ëç>*Tı`B]6yf≥â¯;`lBπ∂Ú7ƒf@Q˛¬8ﬂ$Â∑RUy64T∑˚≠L‚Í0Íj4
1ﬂ¥¬98È8c‡∫n
’á•H◊ï˜iq:âr=y^[[Jœòt¡ﬂ–Ë•7p†ºëwª∑ê¡ñDQËØçäÇÖÕÕPâ∞? gfPâª“á5Ôˇ¥A=  Øﬂﬂg^ØÙ'>›∆¯F(O>±˛ëòùXeÎÌ=T2y÷Ÿ©ë˛(© "wûxömÛ›C∏Ø>HÌp„∫ô#‚èÇOøEÉ ®Ü°GB°ŒI|St‹¸‡pH~Ê¿_ª?>˝ëc™—ãˇ>˙tºq6”¶≠(}‰,òIFìÂÓnQÌ≠g¯ú#%õÕƒá ¶®#øÿ<º®Æ6+[R:yEi±îi‰ôM√∫ôGÀ·:
sÁ˜ﬁº˘f8}Ù∂U≠•ìg¨∆R∂Ÿ¿™\®!∑©4&Mäˇ--ñ3aUKâ"âœpôì
ï[¯$Xbôá”’ér»[V;9Ú5<TÜπ@m§∑_:y!åLUÙˇ0Í∞ÙL£Úô¡•@0V˛E≤õ‰,I-…∑H~BRW|ìï#?a⁄Í>&ÍyàÔ"ŸD]„i∫˜©ªØ–ı$≠≈5Y9Ú¥™:TÈI9F˛$IGÒ8ƒezÍ˚Ù£»(;&yvÒ¢uuñôB)™†ëf:ÑπF¥så¸ÛD2öªqå⁄íÆ4gLŒIå"[ˆ.\Eìc5Á√„i»ﬁöeî¡Öñıf¬G∞πÄ“…≥p∏çV∞?Ò±M0ÊÃ(CeY|"Åö‹UI9iì‰iC·°º¸(ëh.ŒD¬π∑ÂÆß%árW3yŸdÏ¡7ﬁP±b≈>q …q‡ –’Éÿi∑q#0ujJGÈ WÚ¨∞î≤?”U!Ò—ˇŒ®ﬂÅ¬ﬁN&y,_˛ üõ‘ hÈR‡˙ı‹O∂∂Î◊ß 4aûg˛ììEü§1yÇ˙Ÿ+∆¿‰N˜)íu≈OëgÏ°§Ü6uÀ¡{=ÄoØi¿‚‹p8≠”P≥1Ãˇ∆ÔË·óì∫ı≠Ë—'Áû∞°öy∫¯"ÌÃﬂÇ9“_&©*ûxä<pgRs ºWXπ¯√´C§*»–<g¶jn⁄˙”F'W∏î=syÈﬂK'Ètf◊kLQ¢—¶§¶ß'vπÁû¬ç«‡∞Éi⁄è⁄»®ûı©†~9I≤«ﬂ‚†·‰Iç‹&ïﬁí€H‘∂Ü‘	∏!&yá—deöy-Å@¸ábyP‰úa2†É9tê;33?hN#Dc£ç GÛ„“•¯è¶¶tıpNÚ÷ºlDUL‰;◊‡Î4pÉ¥Õ∑§#J≥Áµ}6º˝∂mb#"≥f•W˜‰$œÛ,ñŸ MJlyVYô€Ù‹öÜkë/·|/©Ô›˚Æøà°≥WLMCônË˝>å|tLepÓy˛ÙÕÁG*ñU˙yººÜ&Q$Á=≤¶«’å3∂πxkízGﬂuW.É=g}@í]∞ b€6¯Ô∫+•¢˚˜.ôº{å®
s§€lóQ•ÑÚÓ£¢4Ú5'ª·Ú|≈jkÛf`√≥êWyJ6n‹Ë9$Dò≠ÌÌ—í»K_ÙˇÉ)ÏπæÉzxâ’8Qw¨>~†øÄs—ô8Uıu*ôÑ»≥ò1∫$ïâ™*Î5Ñíª<$4Ìü±˛ïB^éˆ2ÌØ8œo«F}'ˆ8:P£Ö0^ıM~˛ÖÕf‹°^†{SIº!£Õ©n9É≈5hû√Åatª˝BB]≤€¸⁄æ?‘ü«9>ÎıgiÒiÑW‘°C'¯|4∞!<kúHë∑9 Ô≤Ø¡◊b=Ø"r€`¶;íd"ò”æFP
á>"}L8g∆Ôí…;…ÎÔXáÔÜˆ‚u#9ŒDg„v•Ø9∆D÷oy&@3v”[ef©°–¬Â∫:™ëÑøÀÃ,(+⁄H_ﬁÔ\â«¬;pñœéÈ&≤õÿmÕƒ%8qÒŸmÂY»äAŸ°Rv`ß˝ÁË?EÆ”Ä]ˆÕYâ'aDÕÛ˜
†"q^∫–sˆMcﬁ;õw⁄1¢™cﬁ[*wÙQ "mÇü”¸ÀHn“√"πíóI°6©¬ñë‹0Vdh‚s%/ó™õ\»%≠"M>û3gF≥J`$Dyˇ˚Á ZÁY+xi«Àöò7œ`B¯È’ôﬂKfÃà]:;Å’´À#õâwﬂ%ûﬁÄı‘AÊ–˝˝»\∏
@b‰OìòﬂK⁄€Q˝≥xÈ•∆èÓøü∂lfû$ÁôÆÈd8óÎãè÷…√áÅÌ€È≈∫Ï‡´V•ﬂ÷-ZZJ˘ÿ_!ˆRK&yb∫dﬂ:¸m˘ãÿ±√ )≈lé∆
ö^˛%n»cìÑ¯cæ›W^{±ø}}Ø`˙Ù2‚ë≈Kv][@√ú?o~íyÖRƒÊ3˝…Ìø«É»⁄µ∏·Ò§Ôß=Û.‘÷ñN^æ6â¨Ñ™æóÙ˝)SÄ≠[K2Zd^Œ˘jQ[{´T…hC9Ú)Í¿7©Ú†uzeÊÄD|çP’øóc∆*©'ÿ‡‡pª7R‰qˇmÒÔ˝ïÅ}Ù˜u;Euı@πÊF≈y—ÿ(ˇˇeªÊı÷√Âö_j<œÁ=ìû«4n&	'æbóâˇ0loD    IENDÆB`Ç{
  "manifest_version": 3,
  "name": "Bit√°cora EVA",
  "version": "2.0",
  "description": "Registra mensajes e inyecta texto en ChatGPT, guardando la bit√°cora local.",
  "permissions": [
    "storage",
    "downloads",
    "activeTab",
    "scripting"
  ],
  "background": {
    "service_worker": "background.js"
  },
  "action": {
    "default_popup": "popup.html",
    "default_icon": {
      "16": "icon.png",
      "48": "icon.png",
      "128": "icon.png"
    }
  },
  "content_scripts": [
    {
      "matches": [
        "*://chat.openai.com/*",
        "*://chatgpt.com/*"
      ],
      "js": ["content.js"],
      "run_at": "document_idle"
    }
  ]
}
/* ARCHIVO popup.css */
/* ------------------------------------- */

body {
  font-family: Arial, sans-serif;
  width: 300px;
  padding: 10px;
}

h2 {
  text-align: center;
  color: #444;
}

textarea {
  width: 100%;
  margin-top: 10px;
}

button {
  margin-top: 10px;
  width: 48%;
  padding: 5px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

#enviar {
  background-color: #4caf50;
  color: white;
}

#guardar {
  background-color: #2196f3;
  color: white;
}

#estado {
  margin-top: 10px;
  font-size: 0.9em;
  color: #666;
}
<!-- ARCHIVO poput.html>
<!//---------------------------------->



<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Popup Prototype ‚Äî Bit√°cora & Env√≠o</title>
  <style>
    :root{font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;}
    body{margin:12px; color:#111; font-size:14px;}
    h1{font-size:18px;margin:0 0 8px}
    label{display:block;margin-top:8px;font-weight:600}
    input[type=text], textarea, select{width:100%;box-sizing:border-box;padding:8px;border-radius:6px;border:1px solid #ccc}
    textarea{min-height:220px;resize:vertical}
    .row{display:flex;gap:8px}
    .col{flex:1}
    button{padding:8px 10px;border-radius:8px;border:0;background:#2b76d6;color:white;cursor:pointer}
    button.secondary{background:#666}
    .small{font-size:12px;color:#555}
    .controls{display:flex;gap:8px;margin-top:8px}
    .meta{background:#f6f8fb;padding:8px;border-radius:8px;margin-top:8px}
    .log{margin-top:12px;max-height:200px;overflow:auto;padding:8px;border:1px solid #eee;background:#fff}
    .tag{display:inline-block;padding:2px 6px;border-radius:6px;background:#eef;margin-right:6px;margin-bottom:6px;font-size:12px}
    .fieldset{border:1px dashed #ddd;padding:8px;border-radius:8px;margin-top:8px}
    .muted{color:#777;font-size:12px}
  </style>
</head>
<body>
  <h1>Bit√°cora / Env√≠o ‚Äî Prototipo</h1>

  <label>Destinatario (fijo hasta cerrar)</label>
  <input id="recipient" placeholder="Nombre del destinatario..."/>

  <div style="display:flex;gap:8px;margin-top:8px">
    <div style="flex:1">
      <label>Autor / Remitente</label>
      <input id="author" placeholder="Tu nombre..." />
    </div>
    <div style="width:120px">
      <label class="small">Mensaje ID</label>
      <div id="msgId" class="muted">1</div>
    </div>
  </div>

  <div class="fieldset">
    <label>Categor√≠as (se guardan como c√≥digos, ej. c4t/)</label>
    <div style="display:flex;flex-wrap:wrap;gap:8px;margin-top:6px">
      <label><input type="checkbox" data-code="c4t"/> Informe (c4t/)</label>
      <label><input type="checkbox" data-code="c5t"/> Idea (c5t/)</label>
      <label><input type="checkbox" data-code="c6t"/> Ayuda (c6t/)</label>
      <label><input type="checkbox" data-code="c7t"/> Importante (c7t/)</label>
      <label><input type="checkbox" data-code="c8t"/> Inspiraci√≥n (c8t/)</label>
    </div>
  </div>

  <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
    <label style="margin:0;flex:1">Inputs adicionales (activar para incluir en el archivo)</label>
    <label style="font-size:12px"><input id="toggleExtra" type="checkbox"/> Activar</label>
  </div>
  <div id="extraInputs" style="display:none;margin-top:8px">
    <label>Campo extra 1</label>
    <input id="extra1" placeholder="Meta / canal / proyecto" />
    <label style="margin-top:6px">Campo extra 2</label>
    <input id="extra2" placeholder="Etiqueta libre" />
  </div>

  <label style="margin-top:10px">Mensaje (hasta 20.000 caracteres). El primer car√°cter guarda la hora/fecha</label>
  <textarea id="message" maxlength="20000" placeholder="Escribe aqu√≠... (Enter funciona normalmente)"></textarea>
  <div class="small muted">Caracteres: <span id="length">0</span> / 20000</div>

  <div class="controls">
    <button id="send">Compartir tu informaci√≥n singular</button>
    <button id="repeat" class="secondary">Repetir √∫ltimo</button>
    <button id="download" class="secondary">Descargar bit√°cora</button>
    <button id="clear" class="secondary">Nueva Bit√°cora</button>
  </div>

  <div class="meta">
    <div class="small">Estado: <span id="status">idle</span></div>
    <div class="small">Observador del frontend (opcional, selector): <input id="observerSelector" placeholder="ej. div.text-base" style="width:240px"/></div>
    <div class="small">Bot√≥n Inject (intenta colocar y enviar en la p√°gina actual)</div>
    <div style="margin-top:8px"><button id="inject">Injectar e intentar enviar</button></div>
  </div>

  <div style="margin-top:10px">
    <strong>Bit√°cora (√∫ltimos 15 registros)</strong>
    <div id="log" class="log"></div>
  </div>
<script src="popup.js"></script>

</body>
</html>  // --- ARCHIVO popup.js
  // --- -------------------------------------

  // --- Simple storage using localStorage (append)
  const LS_KEY = 'pec_log_v1';
  const LS_COUNTER = 'pec_log_counter';

  function loadState(){
    const raw = localStorage.getItem(LS_KEY);
    const arr = raw ? JSON.parse(raw) : [];
    const counter = parseInt(localStorage.getItem(LS_COUNTER) || '1', 10);
    return {arr, counter};
  }
  function saveState(arr, counter){
    localStorage.setItem(LS_KEY, JSON.stringify(arr));
    localStorage.setItem(LS_COUNTER, ''+counter);
  }

  // --- UI refs
  const recipientEl = document.getElementById('recipient');
  const authorEl = document.getElementById('author');
  const msgIdEl = document.getElementById('msgId');
  const messageEl = document.getElementById('message');
  const lengthEl = document.getElementById('length');
  const sendBtn = document.getElementById('send');
  const repeatBtn = document.getElementById('repeat');
  const downloadBtn = document.getElementById('download');
  const clearBtn = document.getElementById('clear');
  const logEl = document.getElementById('log');
  const toggleExtra = document.getElementById('toggleExtra');
  const extraInputs = document.getElementById('extraInputs');
  const injectBtn = document.getElementById('inject');
  const statusEl = document.getElementById('status');
  const observerSelector = document.getElementById('observerSelector');

  // --- Init
  let state = loadState();
  let lastSent = null;
  updateUI();

  // --- helpers
  function fmtDate(d){
    return d.toLocaleString();
  }
  function getCheckedCategories(){
    const checked = [];
    document.querySelectorAll('.fieldset input[type=checkbox]').forEach(cb=>{
      if(cb.checked)checked.push(cb.dataset.code);
    });
    return checked.join('/');
  }

  function buildHeader(msgId){
    const recipient = recipientEl.value.trim() || 'DESTINATARIO_NO_DEFINIDO';
    const author = authorEl.value.trim() || 'AUTOR_NO_DEFINIDO';
    const now = new Date();
    const categories = getCheckedCategories();
    const extra1 = document.getElementById('extra1').value.trim();
    const extra2 = document.getElementById('extra2').value.trim();
    return `Nombre del destinatario del mensaje/canalizaci√≥n: ${recipient}\n\n`+
           `Mensaje (incremento +${msgId}) de ${author} hora y fecha: ${fmtDate(now)}\n`+
           `Destinatario: ${recipient}\n`+
           `${categories?('Categorias:'+categories+'\n'):''}`+
           `${toggleExtra.checked ? `Extra1:${extra1} Extra2:${extra2}\n` : ''}`+
           `^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n`;
  }

  function buildFooter(){
    const now = new Date();
    const author = authorEl.value.trim() || 'AUTOR_NO_DEFINIDO';
    return `\n----------------------------------------------------------------------\nFIN DEL MENSAJE [x]-----------enviado ${fmtDate(now)} por ${author}\n`;
  }

  function appendLog(entry){
    state.arr.push(entry);
    state.counter = state.counter + 1;
    saveState(state.arr, state.counter);
    lastSent = entry;
    renderLog();
  }

  function renderLog(){
    msgIdEl.textContent = (state.counter || 1);
    logEl.innerHTML = '';
    const recent = state.arr.slice(-15).reverse();
    for(const e of recent){
      const div = document.createElement('div');
      div.style.padding='6px';
      div.style.borderBottom='1px solid #f0f0f0';
      div.innerHTML = `<div class="small muted">${e.header.replace(/\n/g,'<br>')}</div><pre style="white-space:pre-wrap">${e.body}</pre><div class="muted small">${e.footer.replace(/\n/g,'<br>')}</div>`;
      logEl.appendChild(div);
    }
  }

  // --- send flow
  function sendMessage(){
    const text = messageEl.value;
    if(!text.trim()){ alert('Mensaje vac√≠o. Escribe algo.'); return; }
    const id = state.counter || 1;
    const header = buildHeader(id);
    const footer = buildFooter();
    const entry = {id, header, body: text, footer, ts: Date.now()};
    appendLog(entry);
    statusEl.textContent = 'enviando...';

    // Try to inject into page contentEditable/textarea and click send
    tryInjectToPage(text);

    // After appending, clear textarea for next fragment
    messageEl.value = '';
    lengthEl.textContent = '0';
    statusEl.textContent = 'esperando respuesta (observer si configurado)';
  }

  // --- repeat last
  function repeatLast(){
    if(!lastSent) return alert('No hay mensaje previo para repetir');
    // re-inject body
    tryInjectToPage(lastSent.body);
  }

  // --- inject function (best-effort)
  function tryInjectToPage(text){
    // Prefer contentEditable if present
    const editable = findEditable();
    if(editable){
      // If it's a textarea
      if(editable.tagName === 'TEXTAREA'){
        const ta = editable;
        const { selectionStart, selectionEnd } = ta;
        ta.value = text;
        ta.selectionStart = ta.selectionEnd = ta.value.length;
        ta.dispatchEvent(new Event('input', {bubbles:true}));
      } else if(editable.isContentEditable){
        // set text inside
        // replace innerHTML with escaped text inside a <div>
        editable.focus();
        // for safety, try to insert plain text preserving newlines
        const lines = text.split('\n');
        editable.innerHTML = '';
        for(let i=0;i<lines.length;i++){
          const span = document.createElement('div');
          span.textContent = lines[i];
          editable.appendChild(span);
        }
        // dispatch input
        editable.dispatchEvent(new InputEvent('input', {bubbles:true}));
      }

      // find send button dynamically
      const sendBtn = findSendButton();
      if(sendBtn){
        // small delay to let React reconcile
        setTimeout(()=>{
          try{ sendBtn.click(); statusEl.textContent='mensaje enviado (click)'; }catch(e){ console.warn(e); statusEl.textContent='error click'; }
        }, 120);
      } else {
        // fallback: copy to clipboard and inform user
        navigator.clipboard.writeText(text).then(()=>{
          alert('Texto copiado al portapapeles. Pega manualmente en el editor y env√≠a.');
          statusEl.textContent='copiado al portapapeles (fallback)';
        }).catch(()=>{
          alert('No se pudo inyectar ni copiar. No hay editor detectable.');
        });
      }
    } else {
      alert('No se detect√≥ editor en la p√°gina. Puedes pegar manualmente.');
    }
  }

  function findEditable(){
    // heur√≠sticos: contentEditable div, or visible textarea
    const ta = document.querySelector('textarea:not([style*="display: none"]), textarea:not([hidden])');
    if(ta && ta.offsetParent !== null) return ta;
    const editable = document.querySelector('[contenteditable="true"]');
    if(editable) return editable;
    // try more generic
    const ed2 = Array.from(document.querySelectorAll('[contenteditable]')).find(e=>e.getAttribute('contenteditable')!=='false');
    if(ed2) return ed2;
    return null;
  }

  function findSendButton(){
    // try common selectors; best-effort
    return document.querySelector('#composer-submit-button') || document.querySelector('button[data-testid="send-button"]') || document.querySelector('button[aria-label*="Enviar"], button[aria-label*="Send"]');
  }

  // --- download log
  function downloadLog(){
    const content = state.arr.map(e=>e.header+e.body+e.footer).join('\n\n-----\n\n');
    const blob = new Blob([content], {type:'text/plain;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `bitacora_${(new Date()).toISOString().replace(/[:.]/g,'-')}.txt`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  // --- new bitacora
  function clearLog(){
    if(!confirm('Crear nueva bit√°cora y borrar la actual?')) return;
    state.arr = [];
    state.counter = 1;
    saveState(state.arr, state.counter);
    renderLog();
  }

  // --- toggle extra inputs
  toggleExtra.addEventListener('change', ()=>{
    extraInputs.style.display = toggleExtra.checked ? 'block' : 'none';
  });

  messageEl.addEventListener('input', ()=>{
    lengthEl.textContent = messageEl.value.length;
  }, {passive:true});

  // --- first char time capture
  let firstCharCaptured = false;
  messageEl.addEventListener('keydown', (e)=>{
    if(!firstCharCaptured && e.key.length===1){
      // first printable char pressed
      firstCharCaptured = true;
      const now = new Date();
      // prepend header visually in a small note (not in textarea)
      console.log('Primer caracter detectado a las', now.toLocaleString());
      statusEl.textContent = 'primer caracter: '+now.toLocaleString();
    }
  });

  // attach controls
  sendBtn.addEventListener('click', sendMessage);
  repeatBtn.addEventListener('click', repeatLast);
  downloadBtn.addEventListener('click', downloadLog);
  clearBtn.addEventListener('click', clearLog);

  injectBtn.addEventListener('click', ()=>{
    const text = messageEl.value || (lastSent && lastSent.body) || '';
    if(!text) return alert('Nada para inyectar');
    tryInjectToPage(text);
  });

  // --- observer optional watch on target selector
  let observer = null;
  document.getElementById('observerSelector').addEventListener('change', ()=>{
    const sel = observerSelector.value.trim();
    if(observer){ observer.disconnect(); observer = null; statusEl.textContent='observer detenido'; }
    if(sel){
      const el = document.querySelector(sel);
      if(!el) return alert('Selector no encontrado en esta p√°gina');
      observer = new MutationObserver((muts)=>{
        statusEl.textContent = 'Cambio detectado en target: '+new Date().toLocaleTimeString();
        // Cuando cambia el DOM, habilitar bot√≥n de env√≠o del popup
        sendBtn.disabled = false;
      });
      observer.observe(el, {childList:true, subtree:true, characterData:true});
      statusEl.textContent='observer activo en '+sel;
    }
  });

  // --- init state
  (function init(){
    if(!state.arr) state.arr = [];
    if(!state.counter) state.counter = 1;
    renderLog();
  })();
