// ARCHIVO: background.js
//------------------------------------------------


chrome.runtime.onInstalled.addListener(() => {
  console.log("BitÃ¡cora EVA instalada.");
});
// background.js - gestor simple de bitÃ¡cora
chrome.runtime.onInstalled.addListener(() => {
  console.log('[EVA background] installed');
});

// escucha mensajes de content.js
chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
  if(msg && msg.type === 'EVA_SAVE_REPLY' && msg.entry){
    chrome.storage.local.get({ bitacora: [] }, (res) => {
      const arr = res.bitacora || [];
      arr.push(msg.entry);
      chrome.storage.local.set({ bitacora: arr }, () => {
        console.log('[EVA background] entry saved. total=', arr.length);
        sendResponse({ ok: true, total: arr.length });
      });
    });
    // keep message channel open for async response
    return true;
  }
});
// ARCHIVO : content.js
// -----------------------------------------

// Escucha mensajes desde popup.js
window.addEventListener("message", (event) => {
  if (event.data.type === "EVA_SEND") {
    const { dest, msg } = event.data;

    const box = document.querySelector("div[contenteditable='true']");
    if (box) {
      box.innerHTML = `${msg}\n\n(Destinatario: ${dest})`;
      box.dispatchEvent(new InputEvent("input", { bubbles: true }));

      // Encontrar botÃ³n de enviar
      const sendBtn = document.querySelector("button[data-testid='send-button']");
      if (sendBtn) sendBtn.click();
    }
  }
});

// content.js - observar respuestas y enviar texto al background
(function(){
  console.log('[EVA] content script: observer for copy-based capture ready');

  // selectores probables para el botÃ³n "copiar"
  const COPY_SELECTORS = [
    'button[aria-label="Copiar"]',
    'button[aria-label="Copy"]',
    'button[title="Copiar"]',
    'button[aria-label*="Copiar"]',
    'button[data-testid*="copy"]',
    'button[aria-label*="Copy"]'
  ];

  // intenta encontrar texto de respuesta desde el nodo (recorrido heurÃ­stico)
  function findResponseTextFromNode(node){
    if(!node) return null;
    // primer intento: buscar un elemento con clase que parezca "text-base"
    let txt = node.querySelector && ( node.querySelector('.text-base') || node.querySelector('[data-testid="message-text"]') || node.querySelector('div[class*="text-"]') );
    if(txt && txt.innerText && txt.innerText.trim()) return txt.innerText.trim();

    // segundo intento: buscar cualquier <pre> o div con texto dentro del nodo
    const candidates = node.querySelectorAll ? node.querySelectorAll('pre,div') : [];
    for(const c of candidates){
      if(c.innerText && c.innerText.trim().length > 10){
        return c.innerText.trim();
      }
    }

    // tercer intento: subir por ancestros y buscar .text-base
    let anc = node;
    for(let i=0;i<6 && anc; i++){
      if(anc.querySelector){
        const t = anc.querySelector('.text-base, [data-testid="message-text"], div[class*="text-"]');
        if(t && t.innerText && t.innerText.trim()) return t.innerText.trim();
      }
      anc = anc.parentElement;
    }

    // fallback: return node.innerText if suficiente
    if(node.innerText && node.innerText.trim().length > 10) return node.innerText.trim();

    return null;
  }

  function alreadySaved(node){
    try { return node.dataset && node.dataset.evaSaved === '1'; } catch(e){ return false; }
  }
  function markSaved(node){
    try { if(node.dataset) node.dataset.evaSaved = '1'; } catch(e){}
  }

// content.js (agregado al codigo por sugerencia de tu Ãºltimo mensaje)

function getLastResponseText() {
  // Selecciona todos los botones de copiar (en espaÃ±ol)
  const copyBtns = document.querySelectorAll('button[aria-label="Copiar"]');
  if (!copyBtns.length) return null;

  // Ãšltimo botÃ³n = Ãºltimo mensaje de la conversaciÃ³n
  const lastBtn = copyBtns[copyBtns.length - 1];

  // Simula un click para copiar al portapapeles
  lastBtn.click();

  // Ahora intentamos leer desde el portapapeles
  return navigator.clipboard.readText();
}

window.addEventListener("message", async (event) => {
  if (event.data.type === "EVA_GET_LAST") {
    try {
      const text = await getLastResponseText();
      window.postMessage({ type: "EVA_LAST_TEXT", text }, "*");
    } catch (err) {
      console.error("Error al leer Ãºltimo mensaje:", err);
      window.postMessage({ type: "EVA_LAST_TEXT", text: null }, "*");
    }
  }
});




  // procesar un nodo nuevo que probablemente contenga una respuesta
  function processAddedNode(node){
    if(node.nodeType !== 1) return;
    // buscar botones copy dentro
    for(const s of COPY_SELECTORS){
      const btns = node.querySelectorAll ? node.querySelectorAll(s) : [];
      if(btns.length){
        for(const btn of btns){
          if(alreadySaved(btn)) continue;
          // encontrar contenedor de mensaje mÃ¡s cercano (heurÃ­stico)
          const container = btn.closest('[data-testid]') || btn.closest('article') || btn.parentElement;
          const text = findResponseTextFromNode(container) || findResponseTextFromNode(node);
          if(text){
            // preparar entrada
            const entry = {
              source: 'chatgpt-reply',
              ts: Date.now(),
              text: text
            };
            // enviar al background para guardar
            chrome.runtime.sendMessage({ type: 'EVA_SAVE_REPLY', entry }, (resp) => {
              // opcional: log
              console.log('[EVA] saved reply to background', resp);
            });
            markSaved(btn);
          } else {
            // marcar para no reintentar infinitamente
            markSaved(btn);
          }
        }
        // ya procesamos buttons dentro de este selector
      }
    }
  }

  // observer: vigilar el contenedor de conversaciones
  function attachObserver() {
    // heurÃ­stica para el contenedor principal de mensajes (varÃ­a segÃºn UI)
    const possible = [
      document.querySelector('div[data-testid="conversation-turns"]'),
      document.querySelector('div[class*="conversation"]'),
      document.querySelector('main')
    ];
    let root = possible.find(x=>x);
    if(!root){
      root = document.body;
      console.warn('[EVA] no conversation-turns encontrado, observando document.body (menos eficiente)');
    } else {
      console.log('[EVA] observando nodo de conversaciÃ³n:', root);
    }

    const observer = new MutationObserver((mutations)=>{
      for(const m of mutations){
        for(const n of m.addedNodes){
          processAddedNode(n);
        }
      }
    });

    observer.observe(root, { childList: true, subtree: true });
    // tambiÃ©n, procesar lo ya presente (inicial scan)
    Array.from(document.querySelectorAll(COPY_SELECTORS.join(','))).forEach(btn=>{
      const container = btn.closest('[data-testid]') || btn.closest('article') || btn.parentElement;
      const text = findResponseTextFromNode(container) || findResponseTextFromNode(btn);
      if(text){
        chrome.runtime.sendMessage({ type: 'EVA_SAVE_REPLY', entry: { source:'initial-scan', ts:Date.now(), text }});
        markSaved(btn);
      }
    });
  }

  // esperar que el DOM estÃ© listo
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', attachObserver);
  } else {
    attachObserver();
    attachObserver();
    attachObserver();
  }

})();


// Observa nuevas respuestas de ChatGPT
const chatContainer = document.querySelector("div[data-testid='conversation-turns']");
if (chatContainer) {
  const observer = new MutationObserver(() => {
    console.log("Nueva respuesta detectada en ChatGPT");
  });
  observer.observe(chatContainer, { childList: true, subtree: true });
}
‰PNG
{
  "manifest_version": 3,
  "name": "BitÃ¡cora EVA",
  "version": "2.0",
  "description": "Registra mensajes e inyecta texto en ChatGPT, guardando la bitÃ¡cora local.",
  "permissions": [
    "storage",
    "downloads",
    "activeTab",
    "scripting"
  ],
  "background": {
    "service_worker": "background.js"
  },
  "action": {
    "default_popup": "popup.html",
    "default_icon": {
      "16": "icon.png",
      "48": "icon.png",
      "128": "icon.png"
    }
  },
  "content_scripts": [
    {
      "matches": [
        "*://chat.openai.com/*",
        "*://chatgpt.com/*"
      ],
      "js": ["content.js"],
      "run_at": "document_idle"
    }
  ]
}
/* ARCHIVO popup.css */
/* ------------------------------------- */

body {
  font-family: Arial, sans-serif;
  width: 300px;
  padding: 10px;
}

h2 {
  text-align: center;
  color: #444;
}

textarea {
  width: 100%;
  margin-top: 10px;
}

button {
  margin-top: 10px;
  width: 48%;
  padding: 5px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

#enviar {
  background-color: #4caf50;
  color: white;
}

#guardar {
  background-color: #2196f3;
  color: white;
}

#estado {
  margin-top: 10px;
  font-size: 0.9em;
  color: #666;
}
<!-- ARCHIVO poput.html>
<!//---------------------------------->



<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Popup Prototype â€” BitÃ¡cora & EnvÃ­o</title>
  <style>
    :root{font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;}
    body{margin:12px; color:#111; font-size:14px;}
    h1{font-size:18px;margin:0 0 8px}
    label{display:block;margin-top:8px;font-weight:600}
    input[type=text], textarea, select{width:100%;box-sizing:border-box;padding:8px;border-radius:6px;border:1px solid #ccc}
    textarea{min-height:220px;resize:vertical}
    .row{display:flex;gap:8px}
    .col{flex:1}
    button{padding:8px 10px;border-radius:8px;border:0;background:#2b76d6;color:white;cursor:pointer}
    button.secondary{background:#666}
    .small{font-size:12px;color:#555}
    .controls{display:flex;gap:8px;margin-top:8px}
    .meta{background:#f6f8fb;padding:8px;border-radius:8px;margin-top:8px}
    .log{margin-top:12px;max-height:200px;overflow:auto;padding:8px;border:1px solid #eee;background:#fff}
    .tag{display:inline-block;padding:2px 6px;border-radius:6px;background:#eef;margin-right:6px;margin-bottom:6px;font-size:12px}
    .fieldset{border:1px dashed #ddd;padding:8px;border-radius:8px;margin-top:8px}
    .muted{color:#777;font-size:12px}
  </style>
</head>
<body>
  <h1>BitÃ¡cora / EnvÃ­o â€” Prototipo</h1>

  <label>Destinatario (fijo hasta cerrar)</label>
  <input id="recipient" placeholder="Nombre del destinatario..."/>

  <div style="display:flex;gap:8px;margin-top:8px">
    <div style="flex:1">
      <label>Autor / Remitente</label>
      <input id="author" placeholder="Tu nombre..." />
    </div>
    <div style="width:120px">
      <label class="small">Mensaje ID</label>
      <div id="msgId" class="muted">1</div>
    </div>
  </div>

  <div class="fieldset">
    <label>CategorÃ­as (se guardan como cÃ³digos, ej. c4t/)</label>
    <div style="display:flex;flex-wrap:wrap;gap:8px;margin-top:6px">
      <label><input type="checkbox" data-code="c4t"/> Informe (c4t/)</label>
      <label><input type="checkbox" data-code="c5t"/> Idea (c5t/)</label>
      <label><input type="checkbox" data-code="c6t"/> Ayuda (c6t/)</label>
      <label><input type="checkbox" data-code="c7t"/> Importante (c7t/)</label>
      <label><input type="checkbox" data-code="c8t"/> InspiraciÃ³n (c8t/)</label>
    </div>
  </div>

  <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
    <label style="margin:0;flex:1">Inputs adicionales (activar para incluir en el archivo)</label>
    <label style="font-size:12px"><input id="toggleExtra" type="checkbox"/> Activar</label>
  </div>
  <div id="extraInputs" style="display:none;margin-top:8px">
    <label>Campo extra 1</label>
    <input id="extra1" placeholder="Meta / canal / proyecto" />
    <label style="margin-top:6px">Campo extra 2</label>
    <input id="extra2" placeholder="Etiqueta libre" />
  </div>

  <label style="margin-top:10px">Mensaje (hasta 20.000 caracteres). El primer carÃ¡cter guarda la hora/fecha</label>
  <textarea id="message" maxlength="20000" placeholder="Escribe aquÃ­... (Enter funciona normalmente)"></textarea>
  <div class="small muted">Caracteres: <span id="length">0</span> / 20000</div>

  <div class="controls">
    <button id="send">Compartir tu informaciÃ³n singular</button>
    <button id="repeat" class="secondary">Repetir Ãºltimo</button>
    <button id="download" class="secondary">Descargar bitÃ¡cora</button>
    <button id="clear" class="secondary">Nueva BitÃ¡cora</button>
  </div>

  <div class="meta">
    <div class="small">Estado: <span id="status">idle</span></div>
    <div class="small">Observador del frontend (opcional, selector): <input id="observerSelector" placeholder="ej. div.text-base" style="width:240px"/></div>
    <div class="small">BotÃ³n Inject (intenta colocar y enviar en la pÃ¡gina actual)</div>
    <div style="margin-top:8px"><button id="inject">Injectar e intentar enviar</button></div>
  </div>

  <div style="margin-top:10px">
    <strong>BitÃ¡cora (Ãºltimos 15 registros)</strong>
    <div id="log" class="log"></div>
  </div>
<script src="popup.js"></script>

</body>
</html>  // --- ARCHIVO popup.js
  // --- -------------------------------------

  // --- Simple storage using localStorage (append)
  const LS_KEY = 'pec_log_v1';
  const LS_COUNTER = 'pec_log_counter';

  function loadState(){
    const raw = localStorage.getItem(LS_KEY);
    const arr = raw ? JSON.parse(raw) : [];
    const counter = parseInt(localStorage.getItem(LS_COUNTER) || '1', 10);
    return {arr, counter};
  }
  function saveState(arr, counter){
    localStorage.setItem(LS_KEY, JSON.stringify(arr));
    localStorage.setItem(LS_COUNTER, ''+counter);
  }

  // --- UI refs
  const recipientEl = document.getElementById('recipient');
  const authorEl = document.getElementById('author');
  const msgIdEl = document.getElementById('msgId');
  const messageEl = document.getElementById('message');
  const lengthEl = document.getElementById('length');
  const sendBtn = document.getElementById('send');
  const repeatBtn = document.getElementById('repeat');
  const downloadBtn = document.getElementById('download');
  const clearBtn = document.getElementById('clear');
  const logEl = document.getElementById('log');
  const toggleExtra = document.getElementById('toggleExtra');
  const extraInputs = document.getElementById('extraInputs');
  const injectBtn = document.getElementById('inject');
  const statusEl = document.getElementById('status');
  const observerSelector = document.getElementById('observerSelector');

  // --- Init
  let state = loadState();
  let lastSent = null;
  updateUI();

  // --- helpers
  function fmtDate(d){
    return d.toLocaleString();
  }
  function getCheckedCategories(){
    const checked = [];
    document.querySelectorAll('.fieldset input[type=checkbox]').forEach(cb=>{
      if(cb.checked)checked.push(cb.dataset.code);
    });
    return checked.join('/');
  }

  function buildHeader(msgId){
    const recipient = recipientEl.value.trim() || 'DESTINATARIO_NO_DEFINIDO';
    const author = authorEl.value.trim() || 'AUTOR_NO_DEFINIDO';
    const now = new Date();
    const categories = getCheckedCategories();
    const extra1 = document.getElementById('extra1').value.trim();
    const extra2 = document.getElementById('extra2').value.trim();
    return `Nombre del destinatario del mensaje/canalizaciÃ³n: ${recipient}\n\n`+
           `Mensaje (incremento +${msgId}) de ${author} hora y fecha: ${fmtDate(now)}\n`+
           `Destinatario: ${recipient}\n`+
           `${categories?('Categorias:'+categories+'\n'):''}`+
           `${toggleExtra.checked ? `Extra1:${extra1} Extra2:${extra2}\n` : ''}`+
           `^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n`;
  }

  function buildFooter(){
    const now = new Date();
    const author = authorEl.value.trim() || 'AUTOR_NO_DEFINIDO';
    return `\n----------------------------------------------------------------------\nFIN DEL MENSAJE [x]-----------enviado ${fmtDate(now)} por ${author}\n`;
  }

  function appendLog(entry){
    state.arr.push(entry);
    state.counter = state.counter + 1;
    saveState(state.arr, state.counter);
    lastSent = entry;
    renderLog();
  }

  function renderLog(){
    msgIdEl.textContent = (state.counter || 1);
    logEl.innerHTML = '';
    const recent = state.arr.slice(-15).reverse();
    for(const e of recent){
      const div = document.createElement('div');
      div.style.padding='6px';
      div.style.borderBottom='1px solid #f0f0f0';
      div.innerHTML = `<div class="small muted">${e.header.replace(/\n/g,'<br>')}</div><pre style="white-space:pre-wrap">${e.body}</pre><div class="muted small">${e.footer.replace(/\n/g,'<br>')}</div>`;
      logEl.appendChild(div);
    }
  }

  // --- send flow
  function sendMessage(){
    const text = messageEl.value;
    if(!text.trim()){ alert('Mensaje vacÃ­o. Escribe algo.'); return; }
    const id = state.counter || 1;
    const header = buildHeader(id);
    const footer = buildFooter();
    const entry = {id, header, body: text, footer, ts: Date.now()};
    appendLog(entry);
    statusEl.textContent = 'enviando...';

    // Try to inject into page contentEditable/textarea and click send
    tryInjectToPage(text);

    // After appending, clear textarea for next fragment
    messageEl.value = '';
    lengthEl.textContent = '0';
    statusEl.textContent = 'esperando respuesta (observer si configurado)';
  }

  // --- repeat last
  function repeatLast(){
    if(!lastSent) return alert('No hay mensaje previo para repetir');
    // re-inject body
    tryInjectToPage(lastSent.body);
  }

  // --- inject function (best-effort)
  function tryInjectToPage(text){
    // Prefer contentEditable if present
    const editable = findEditable();
    if(editable){
      // If it's a textarea
      if(editable.tagName === 'TEXTAREA'){
        const ta = editable;
        const { selectionStart, selectionEnd } = ta;
        ta.value = text;
        ta.selectionStart = ta.selectionEnd = ta.value.length;
        ta.dispatchEvent(new Event('input', {bubbles:true}));
      } else if(editable.isContentEditable){
        // set text inside
        // replace innerHTML with escaped text inside a <div>
        editable.focus();
        // for safety, try to insert plain text preserving newlines
        const lines = text.split('\n');
        editable.innerHTML = '';
        for(let i=0;i<lines.length;i++){
          const span = document.createElement('div');
          span.textContent = lines[i];
          editable.appendChild(span);
        }
        // dispatch input
        editable.dispatchEvent(new InputEvent('input', {bubbles:true}));
      }

      // find send button dynamically
      const sendBtn = findSendButton();
      if(sendBtn){
        // small delay to let React reconcile
        setTimeout(()=>{
          try{ sendBtn.click(); statusEl.textContent='mensaje enviado (click)'; }catch(e){ console.warn(e); statusEl.textContent='error click'; }
        }, 120);
      } else {
        // fallback: copy to clipboard and inform user
        navigator.clipboard.writeText(text).then(()=>{
          alert('Texto copiado al portapapeles. Pega manualmente en el editor y envÃ­a.');
          statusEl.textContent='copiado al portapapeles (fallback)';
        }).catch(()=>{
          alert('No se pudo inyectar ni copiar. No hay editor detectable.');
        });
      }
    } else {
      alert('No se detectÃ³ editor en la pÃ¡gina. Puedes pegar manualmente.');
    }
  }

  function findEditable(){
    // heurÃ­sticos: contentEditable div, or visible textarea
    const ta = document.querySelector('textarea:not([style*="display: none"]), textarea:not([hidden])');
    if(ta && ta.offsetParent !== null) return ta;
    const editable = document.querySelector('[contenteditable="true"]');
    if(editable) return editable;
    // try more generic
    const ed2 = Array.from(document.querySelectorAll('[contenteditable]')).find(e=>e.getAttribute('contenteditable')!=='false');
    if(ed2) return ed2;
    return null;
  }

  function findSendButton(){
    // try common selectors; best-effort
    return document.querySelector('#composer-submit-button') || document.querySelector('button[data-testid="send-button"]') || document.querySelector('button[aria-label*="Enviar"], button[aria-label*="Send"]');
  }

  // --- download log
  function downloadLog(){
    const content = state.arr.map(e=>e.header+e.body+e.footer).join('\n\n-----\n\n');
    const blob = new Blob([content], {type:'text/plain;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `bitacora_${(new Date()).toISOString().replace(/[:.]/g,'-')}.txt`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  // --- new bitacora
  function clearLog(){
    if(!confirm('Crear nueva bitÃ¡cora y borrar la actual?')) return;
    state.arr = [];
    state.counter = 1;
    saveState(state.arr, state.counter);
    renderLog();
  }

  // --- toggle extra inputs
  toggleExtra.addEventListener('change', ()=>{
    extraInputs.style.display = toggleExtra.checked ? 'block' : 'none';
  });

  messageEl.addEventListener('input', ()=>{
    lengthEl.textContent = messageEl.value.length;
  }, {passive:true});

  // --- first char time capture
  let firstCharCaptured = false;
  messageEl.addEventListener('keydown', (e)=>{
    if(!firstCharCaptured && e.key.length===1){
      // first printable char pressed
      firstCharCaptured = true;
      const now = new Date();
      // prepend header visually in a small note (not in textarea)
      console.log('Primer caracter detectado a las', now.toLocaleString());
      statusEl.textContent = 'primer caracter: '+now.toLocaleString();
    }
  });

  // attach controls
  sendBtn.addEventListener('click', sendMessage);
  repeatBtn.addEventListener('click', repeatLast);
  downloadBtn.addEventListener('click', downloadLog);
  clearBtn.addEventListener('click', clearLog);

  injectBtn.addEventListener('click', ()=>{
    const text = messageEl.value || (lastSent && lastSent.body) || '';
    if(!text) return alert('Nada para inyectar');
    tryInjectToPage(text);
  });

  // --- observer optional watch on target selector
  let observer = null;
  document.getElementById('observerSelector').addEventListener('change', ()=>{
    const sel = observerSelector.value.trim();
    if(observer){ observer.disconnect(); observer = null; statusEl.textContent='observer detenido'; }
    if(sel){
      const el = document.querySelector(sel);
      if(!el) return alert('Selector no encontrado en esta pÃ¡gina');
      observer = new MutationObserver((muts)=>{
        statusEl.textContent = 'Cambio detectado en target: '+new Date().toLocaleTimeString();
        // Cuando cambia el DOM, habilitar botÃ³n de envÃ­o del popup
        sendBtn.disabled = false;
      });
      observer.observe(el, {childList:true, subtree:true, characterData:true});
      statusEl.textContent='observer activo en '+sel;
    }
  });

  // --- init state
  (function init(){
    if(!state.arr) state.arr = [];
    if(!state.counter) state.counter = 1;
    renderLog();
  })();
// ARCHIVO : content.js
// -----------------------------------------

// Escucha mensajes desde popup.js
window.addEventListener("message", (event) => {
  if (event.data.type === "EVA_SEND") {
    const { dest, msg } = event.data;

    const box = document.querySelector("div[contenteditable='true']");
    if (box) {
      box.innerHTML = `${msg}\n\n(Destinatario: ${dest})`;
      box.dispatchEvent(new InputEvent("input", { bubbles: true }));

      // Encontrar botÃ³n de enviar
      const sendBtn = document.querySelector("button[data-testid='send-button']");
      if (sendBtn) sendBtn.click();
    }
  }
});

// content.js - observar respuestas y enviar texto al background
(function(){
  console.log('[EVA] content script: observer for copy-based capture ready');

  // selectores probables para el botÃ³n "copiar"
  const COPY_SELECTORS = [
    'button[aria-label="Copiar"]',
    'button[aria-label="Copy"]',
    'button[title="Copiar"]',
    'button[aria-label*="Copiar"]',
    'button[data-testid*="copy"]',
    'button[aria-label*="Copy"]'
  ];

  // intenta encontrar texto de respuesta desde el nodo (recorrido heurÃ­stico)
  function findResponseTextFromNode(node){
    if(!node) return null;
    // primer intento: buscar un elemento con clase que parezca "text-base"
    let txt = node.querySelector && ( node.querySelector('.text-base') || node.querySelector('[data-testid="message-text"]') || node.querySelector('div[class*="text-"]') );
    if(txt && txt.innerText && txt.innerText.trim()) return txt.innerText.trim();

    // segundo intento: buscar cualquier <pre> o div con texto dentro del nodo
    const candidates = node.querySelectorAll ? node.querySelectorAll('pre,div') : [];
    for(const c of candidates){
      if(c.innerText && c.innerText.trim().length > 10){
        return c.innerText.trim();
      }
    }

    // tercer intento: subir por ancestros y buscar .text-base
    let anc = node;
    for(let i=0;i<6 && anc; i++){
      if(anc.querySelector){
        const t = anc.querySelector('.text-base, [data-testid="message-text"], div[class*="text-"]');
        if(t && t.innerText && t.innerText.trim()) return t.innerText.trim();
      }
      anc = anc.parentElement;
    }

    // fallback: return node.innerText if suficiente
    if(node.innerText && node.innerText.trim().length > 10) return node.innerText.trim();

    return null;
  }

  function alreadySaved(node){
    try { return node.dataset && node.dataset.evaSaved === '1'; } catch(e){ return false; }
  }
  function markSaved(node){
    try { if(node.dataset) node.dataset.evaSaved = '1'; } catch(e){}
  }

// content.js (agregado al codigo por sugerencia de tu Ãºltimo mensaje)

function getLastResponseText() {
  // Selecciona todos los botones de copiar (en espaÃ±ol)
  const copyBtns = document.querySelectorAll('button[aria-label="Copiar"]');
  if (!copyBtns.length) return null;

  // Ãšltimo botÃ³n = Ãºltimo mensaje de la conversaciÃ³n
  const lastBtn = copyBtns[copyBtns.length - 1];

  // Simula un click para copiar al portapapeles
  lastBtn.click();

  // Ahora intentamos leer desde el portapapeles
  return navigator.clipboard.readText();
}

window.addEventListener("message", async (event) => {
  if (event.data.type === "EVA_GET_LAST") {
    try {
      const text = await getLastResponseText();
      window.postMessage({ type: "EVA_LAST_TEXT", text }, "*");
    } catch (err) {
      console.error("Error al leer Ãºltimo mensaje:", err);
      window.postMessage({ type: "EVA_LAST_TEXT", text: null }, "*");
    }
  }
});




  // procesar un nodo nuevo que probablemente contenga una respuesta
  function processAddedNode(node){
    if(node.nodeType !== 1) return;
    // buscar botones copy dentro
    for(const s of COPY_SELECTORS){
      const btns = node.querySelectorAll ? node.querySelectorAll(s) : [];
      if(btns.length){
        for(const btn of btns){
          if(alreadySaved(btn)) continue;
          // encontrar contenedor de mensaje mÃ¡s cercano (heurÃ­stico)
          const container = btn.closest('[data-testid]') || btn.closest('article') || btn.parentElement;
          const text = findResponseTextFromNode(container) || findResponseTextFromNode(node);
          if(text){
            // preparar entrada
            const entry = {
              source: 'chatgpt-reply',
              ts: Date.now(),
              text: text
            };
            // enviar al background para guardar
            chrome.runtime.sendMessage({ type: 'EVA_SAVE_REPLY', entry }, (resp) => {
              // opcional: log
              console.log('[EVA] saved reply to background', resp);
            });
            markSaved(btn);
          } else {
            // marcar para no reintentar infinitamente
            markSaved(btn);
          }
        }
        // ya procesamos buttons dentro de este selector
      }
    }
  }

  // observer: vigilar el contenedor de conversaciones
  function attachObserver() {
    // heurÃ­stica para el contenedor principal de mensajes (varÃ­a segÃºn UI)
    const possible = [
      document.querySelector('div[data-testid="conversation-turns"]'),
      document.querySelector('div[class*="conversation"]'),
      document.querySelector('main')
    ];
    let root = possible.find(x=>x);
    if(!root){
      root = document.body;
      console.warn('[EVA] no conversation-turns encontrado, observando document.body (menos eficiente)');
    } else {
      console.log('[EVA] observando nodo de conversaciÃ³n:', root);
    }

    const observer = new MutationObserver((mutations)=>{
      for(const m of mutations){
        for(const n of m.addedNodes){
          processAddedNode(n);
        }
      }
    });

    observer.observe(root, { childList: true, subtree: true });
    // tambiÃ©n, procesar lo ya presente (inicial scan)
    Array.from(document.querySelectorAll(COPY_SELECTORS.join(','))).forEach(btn=>{
      const container = btn.closest('[data-testid]') || btn.closest('article') || btn.parentElement;
      const text = findResponseTextFromNode(container) || findResponseTextFromNode(btn);
      if(text){
        chrome.runtime.sendMessage({ type: 'EVA_SAVE_REPLY', entry: { source:'initial-scan', ts:Date.now(), text }});
        markSaved(btn);
      }
    });
  }

  // esperar que el DOM estÃ© listo
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', attachObserver);
  } else {
    attachObserver();
    attachObserver();
    attachObserver();
  }

})();


// Observa nuevas respuestas de ChatGPT
const chatContainer = document.querySelector("div[data-testid='conversation-turns']");
if (chatContainer) {
  const observer = new MutationObserver(() => {
    console.log("Nueva respuesta detectada en ChatGPT");
  });
  observer.observe(chatContainer, { childList: true, subtree: true });
}
‰PNG

   IHDR   /   1   JûğG  
7iCCPsRGB IEC61966-2.1  xœ–wTSÙ‡Ï½7½P’Š”ĞkhRH½H‘.*1	JÀ "6DTpDQ‘¦2(à€£C‘±"Š…Q±ëDÔqp–Id­ß¼yïÍ›ß÷~kŸ½Ïİgï}Öº üƒÂLX	€¡XáçÅˆ‹g`ğ l àp³³BøF™|ØŒl™ø½º ùû*Ó?ŒÁ ÿŸ”¹Y"1 P˜ŒçòøÙ\É8=Wœ%·OÉ˜¶4MÎ0JÎ"Y‚2V“sò,[|ö™e9ó2„<ËsÎâeğäÜ'ã9¾Œ‘`çø¹2¾&cƒtI†@Æoä±|N6 (’Ü.æsSdl-c’(2‚-ãy àHÉ_ğÒ/XÌÏËÅÎÌZ.$§ˆ&\S†“‹áÏÏMç‹ÅÌ07#â1Ø™Yár fÏüYym²";Ø8980m-m¾(Ô]ü›’÷v–^„îDøÃöW~™ °¦eµÙú‡mi ]ëP»ı‡Í`/ Š²¾u}qº|^RÄâ,g+«ÜÜ\KŸk)/èïúŸC_|ÏR¾İïåaxó“8’t1C^7nfz¦DÄÈÎâpùæŸ‡øşuü$¾ˆ/”EDË¦L L–µ[Èˆ™B†@øŸšøÃş¤Ù¹–‰ÚøĞ–X¥!@~ (* 	{d+Ğï}ÆGùÍ‹Ñ™˜ûÏ‚ş}W¸LşÈ$cGD2¸QÎìšüZ4  E@ê@èÀ¶À¸ àA(ˆq`1à‚D €µ ”‚­`'¨u 4ƒ6ptcà48.Ë`ÜR0€)ğ
Ì@„…ÈR‡t CÈ²…XäCP”%CBH@ë R¨ª†ê¡fè[è(tº C· Qhúz#0	¦ÁZ°l³`O8„ÁÉğ28.‚·À•p|î„OÃ—àX
?§€:¢‹0ÂFB‘x$	!«¤i@Ú¤¹ŠH‘§È[EE1PL”Ê…â¢–¡V¡6£ªQP¨>ÔUÔ(j
õMFk¢ÍÑÎè t,:‹.FW ›Ğè³èô8úƒ¡cŒ1L&³³³Ó9…ÆŒa¦±X¬:ÖëŠÅr°bl1¶
{{{;}ƒ#âtp¶8_\<Nˆ+ÄUàZp'pWp¸¼ŞïŒÅóğËñeøF|~?Ÿ!(Œ	®„HB*a-¡’ĞF8K¸KxA$õˆNÄp¢€¸†XI<D<O%¾%QHf$6)$!m!í'"İ"½ “ÉFdr<YLŞBn&Ÿ!ß'¿Q *X*(ğV+Ô(t*\Qx¦ˆW4TôT\¬˜¯X¡xDqHñ©^ÉH‰­ÄQZ¥T£tTé†Ò´2UÙF9T9Cy³r‹òåG,ÅˆâCáQŠ(û(g(cT„ªOeS¹ÔuÔFêYê8C3¦ĞRi¥´ohƒ´)ŠŠJ´JJÊq)¡Ñèéô2úaúuú;U-UOU¾ê&Õ6Õ+ª¯Õæ¨y¨ñÕJÔÚÕFÔŞ©3Ô}ÔÓÔ·©w©ßÓ@i˜i„käjìÑ8«ñtmËîœ’9‡çÜÖ„5Í4#4WhîÓĞœÖÒÖòÓÊÒªÒ:£õT›®í¡ª½Cû„ö¤UÇMG ³Cç¤Îc†
Ã“‘Î¨dô1¦t5uıu%ºõºƒº3zÆzQz…zíz÷ô	ú,ı$ıú½úS:!­·ñ†,ÃÃ]†ı†¯ŒbŒ6u=2V30Î7n5¾kB6q7YfÒ`rÍcÊ2M3İmzÙ6³7K1«12‡ÍÌæ»Í‡-ĞNB‹‹LÓ“™ÃleZÒ-ƒ--»,ŸYXÅ[m³ê·úhmonİh}Ç†bhShÓcó«­™-×¶ÆöÚ\ò\ß¹«çvÏ}ngnÇ·ÛcwÓjb¿Á¾×şƒƒ£ƒÈ¡ÍaÒÑÀ1Ñ±Öñ‹Æ
cmfwB;y9­v:æôÖÙÁYì|Øù¦KšK‹Ë£yÆóøóç¹ê¹r\ë]¥n·D·½nRw]w{ƒû}G“Ç„§©gªçAÏg^Ö^"¯¯×lgöJö)oÄÛÏ»Ä{Ğ‡âåSísßWÏ7Ù·ÕwÊÏŞo…ß)´ÿ6ÿZÜ€æ€©@ÇÀ•}A¤ AÕA‚Í‚EÁ=!pH`Èö»óççw…‚Ğ€Ğí¡÷ÂŒÃ–…}	¯	aQÑ¿€º`É‚–¯"½"Ë"ïD™DI¢z££¢›£_ÇxÇ”ÇHc­bWÆ^ŠÓˆÄuÇcã£ã›â§ú,Ü¹p<Á>¡8áú"ãEy‹.,ÖXœ¾øøÅ%œ%GÑ‰1‰-‰ï9¡œÎôÒ€¥µK§¸lî.îoo’ïÊ/çO$¹&•'=JvMŞ<™âR‘òTÀT§ú§Ö¥¾NMÛŸö)=&½=—‘˜qTH¦	û2µ3ó2‡³Ì³Š³¤Ëœ—í\6%
5eCÙ‹²»Å4ÙÏÔ€ÄD²^2šã–S“ó&7:÷Hr0o`¹ÙòMË'ò}ó¿^ZÁ]Ñ[ [°¶`t¥çÊúUĞª¥«zWë¯.Z=¾ÆoÍµ„µik(´.,/|¹.f]O‘VÑš¢±õ~ë[‹ŠEÅ76¸l¨ÛˆÚ(Ø8¸iî¦ªMKx%K­K+Jßoæn¾ø•ÍW•_}Ú’´e°Ì¡lÏVÌVáÖëÛÜ·(W.Ï/Û²½scGÉ—;—ì¼PaWQ·‹°K²KZ\Ù]ePµµê}uJõHWM{­fí¦Ú×»y»¯ìñØÓV§UWZ÷n¯`ïÍz¿úÎ£†Š}˜}9û6F7öÍúº¹I£©´éÃ~á~éˆ}ÍÍÍ-š-e­p«¤uò`ÂÁËßxÓİÆl«o§·—‡$‡›øíõÃA‡{°´}gø]mµ£¤ê\Ş9Õ•Ò%íë>x´·Ç¥§ã{Ëï÷Ó=Vs\åxÙ	Â‰¢ŸNæŸœ>•uêééäÓc½Kzïœ‰=s­/¼oğlĞÙóç|Ïé÷ì?yŞõü±Î^d]ìºäp©sÀ~ ãû:;‡‡º/;]î7|âŠû•ÓW½¯»píÒÈü‘áëQ×oŞH¸!½É»ùèVú­ç·snÏÜYs}·äÒ½Šûš÷~4ı±]ê =>ê=:ğ`Áƒ;cÜ±'?eÿô~¼è!ùaÅ„ÎDó#ÛGÇ&}'/?^øxüIÖ“™§Å?+ÿ\ûÌäÙw¿xü20;5ş\ôüÓ¯›_¨¿ØÿÒîeïtØôıW¯f^—¼Qsà-ëmÿ»˜w3¹ï±ï+?˜~èùôñî§ŒOŸ~÷„óûpf*   	pHYs    Òİ~ü  µIDATxœ½ZlÇşfwïÏøïl°ù·©ÎJAB[‰PS¢¦	!-X*µA"”´8"*U…” AšÒ4E%Q“TŠ’RÚPH“ÆÒ– p,‚qùsl“;ßooïfúæöşö|w¾¿æ“÷æÍî›ofß¼y3kMJE"_…ª>@?o#©'qIuÚ-‘¸ØITd˜D'‘DÂ$<­.@ò	8ïÄ±c‡ÅâÅ‘ôö´ŠÖõVØí/BÓî®„½QPÕÍX´è>*Tõ`B]6yf³‰ø;`lB¹¶ò7Äf@QşÂ8ß$å·RUy64T·û­Lâêğ0êj4
1ß´Â98é8càºn
Õ‡¥H×•÷iq:‰r=y^[[JÏ˜tÁßĞè¥7p ¼‘w»·Á–DQè¯Š‚…ÍÍP‰°? gfP‰»Ò‡5ïÿ´A=  ¯ßßg^¯ô'>İÆøF(O>±ş‘˜Xeëí=T2yÖÙ©‘ş(© "wxšmóİC¸¯>Hípãº™#â‚O¿EƒÊ¨†¡GB¡ÎI|StÜüàpH~æÀ_»?>ı‘cªÑ‹ÿ>út¼q6Ó¦­(}ä,˜IF“åînQí­gğøœ#%›ÍÄ‡Ê¦¨#¿Ø<¼¨®6+[R:yEi±”iä™MÃº™GËá:
sç÷Ş¼ùf8}ô¶U­¥“g¬ÆR¶ÙÀª\¨!·©4&MŠÿ--–3aUK‰"‰Ïp™“
•[ø$Xb™‡ÓÕrÈ[V;9ò5<T†¹@m¤·_:y!ŒLUôÿ0ê°ôL£ò™Á¥@0VşE²›ä,I-É·H~BRW|“•#?aÚê>&êyˆï"ÙD]ãiº÷©»¯Ğõ$­Å5Y9ò´ª:TéI9Fş$IGñ8Äezêûô£È(;&yvñ¢uu–™B)ª ‘f:„¹F´sŒüóD2š»qŒÚ’®4gLÎIŒ"[ö.\E“c5çÃãiÈŞše”Á…–õfÂG°¹€ÒÉ³p¸V°?ñ±M0æÌ(CeY|"šÜUI9i“äiCá¡¼ü(‘h.ÎDÂ¹·å®§%‡rW3yÙdìÁ7ŞP±bÅ>qÊÉqà ĞÕƒØi·q#0ujJGé Wò¬°”²?ÓU!ñÑÿÎ¨ßÂŞN&y,_ş Ÿ›ÔÊhéRàúõÜO¶¶ë×§Ê4agş““EŸ¤1y‚úÙ+ÆÀäN÷)’uÅO‘gì¡¤†6uËÁ{=€o¯iÀâÜp8­ÓP³1ÌÿÆïèá—“ºõ­èÑ'ç°¡šyºø"íÌß‚9Ò_&©*xŠ<pgRsğ ¼WX¹øÃ«C¤*ÈĞ<g¦jnÚúÓF'W¸”=syéßK'étf×kLQ¢Ñ¦¤¦§'v¹çÂÇà°ƒiÚÚÈ¨õ© ~9I²Çßâ áäIÜ&•Ş’ÛHÔ¶†Ô	¸!&y‡Ñdešy-@ü‡byPäœa2 ƒ9t;33?hN#Dc£ÊGóãÒ¥ø¦¦tõpNòÖ¼lDULä;×àë4pƒ´Í·¤#J³çµ}6¼ı¶mb#"³f¥W÷ä$Ïó,–Ù MJlyVY™ÛôÜš†k‘/á|/©ïİû®¿ˆ¡³WLMC™nèı>Œ|tLepîyşôÍçG*–Uúy¼¼†&Q$ç=²¦ÇÕŒ3¶¹xk’zGßuW.ƒ=g}@’]° bÛ6øïº+¥¢û÷.™¼{Œ¨
s¤Ûl—Q¥„òî£¢4ò5'»áò|Åjkóf`Ã³ğWyJ6nÜè9$D˜­ííÑ’ÈK_ôÿƒ)ì¹¾ƒzx‰Õ8Qw¬>~ ¿€sÑ™8Uõu*™„È³˜1º$•‰ª*ë5„’»<$4íŸ±ş•B^ö2í¯8ÏoÇF}'ö8:P£…0^õM~ş…ÍfÜ¡^ {SI¼!£Í©nğ9ƒÅ5hÃat»ıBB]²ÛüÚ¾?ÔŸÇ9>ëõgiñi„WÔ¡C'ø|4°!<kœH‘·9 ï²¯Á×b=¯"rÛ`¦;’d"˜Ó¾FP
‡>"}L8gÆï’É;ÉëïX‡ï†öâu#9ÎDgãv¥¯9ÆDÖoy&@3vğÓ[ğef©¡ĞÂåº:ª‘„¿ËÌ,(+ÚH_Şï\‰ÇÂ;p–Ïé&²›ØmÍÄ%8qñÙmåYÈŠAÙ¡Rv`§ıçè?E®Ó€]öÍY‰'aDÍó÷
 "q^ºĞsöMcŞ;›wÚ1¢ªcŞ[*wôQ "m‚ŸÓüËHnÒÃ"ğ¹’—I¡6©Â–‘Ü0Vdhâs%/—ª›\È%­"M>3gF³J`$Dyÿûç ZçY+xiÇËš˜7Ï`BøéÕ™ßKfÌˆ]:;Õ«Ë#›‰wß%Ş€õÔAæĞııÈ\¸
@bäO“˜ßKÚÛQı³xé¥Æî¿Ÿ¶lf$ç™®éd8—ë‹ÖÉÃ‡íÛéÅºìà«V¥ßÖ-ZZJùØ_!öRK&ybºdß:ümù‹Ø±Ã )ÅlÆ
š^ş%nÈc“„øc¾İW^{±¿}}¯`úô2â‘ÅKv][@Ãœ?o~’y…RÄæ3ıÉí¿ÇƒÈÚµ¸áñ¤ï§=ó.ÔÖ–N^¾6‰¬„ª¾—ôı)S€­[K2Zd^ÎùjQ[{«TÉhC9ò)êÀ7©ò uzeæ€D|PÕ¿—cÆ*©'Øààp»7Räqÿmñïı•}ô÷u;Euõ@¹æFÅyÑØ(ÿÿe»æõÖÃåš_j<Ïç=“Ç4n&	'¾b—‰ÿ0loD    IEND®B`‚{
  "manifest_version": 3,
  "name": "BitÃ¡cora EVA",
  "version": "2.0",
  "description": "Registra mensajes e inyecta texto en ChatGPT, guardando la bitÃ¡cora local.",
  "permissions": [
    "storage",
    "downloads",
    "activeTab",
    "scripting"
  ],
  "background": {
    "service_worker": "background.js"
  },
  "action": {
    "default_popup": "popup.html",
    "default_icon": {
      "16": "icon.png",
      "48": "icon.png",
      "128": "icon.png"
    }
  },
  "content_scripts": [
    {
      "matches": [
        "*://chat.openai.com/*",
        "*://chatgpt.com/*"
      ],
      "js": ["content.js"],
      "run_at": "document_idle"
    }
  ]
}
/* ARCHIVO popup.css */
/* ------------------------------------- */

body {
  font-family: Arial, sans-serif;
  width: 300px;
  padding: 10px;
}

h2 {
  text-align: center;
  color: #444;
}

textarea {
  width: 100%;
  margin-top: 10px;
}

button {
  margin-top: 10px;
  width: 48%;
  padding: 5px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

#enviar {
  background-color: #4caf50;
  color: white;
}

#guardar {
  background-color: #2196f3;
  color: white;
}

#estado {
  margin-top: 10px;
  font-size: 0.9em;
  color: #666;
}
<!-- ARCHIVO poput.html>
<!//---------------------------------->



<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Popup Prototype â€” BitÃ¡cora & EnvÃ­o</title>
  <style>
    :root{font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;}
    body{margin:12px; color:#111; font-size:14px;}
    h1{font-size:18px;margin:0 0 8px}
    label{display:block;margin-top:8px;font-weight:600}
    input[type=text], textarea, select{width:100%;box-sizing:border-box;padding:8px;border-radius:6px;border:1px solid #ccc}
    textarea{min-height:220px;resize:vertical}
    .row{display:flex;gap:8px}
    .col{flex:1}
    button{padding:8px 10px;border-radius:8px;border:0;background:#2b76d6;color:white;cursor:pointer}
    button.secondary{background:#666}
    .small{font-size:12px;color:#555}
    .controls{display:flex;gap:8px;margin-top:8px}
    .meta{background:#f6f8fb;padding:8px;border-radius:8px;margin-top:8px}
    .log{margin-top:12px;max-height:200px;overflow:auto;padding:8px;border:1px solid #eee;background:#fff}
    .tag{display:inline-block;padding:2px 6px;border-radius:6px;background:#eef;margin-right:6px;margin-bottom:6px;font-size:12px}
    .fieldset{border:1px dashed #ddd;padding:8px;border-radius:8px;margin-top:8px}
    .muted{color:#777;font-size:12px}
  </style>
</head>
<body>
  <h1>BitÃ¡cora / EnvÃ­o â€” Prototipo</h1>

  <label>Destinatario (fijo hasta cerrar)</label>
  <input id="recipient" placeholder="Nombre del destinatario..."/>

  <div style="display:flex;gap:8px;margin-top:8px">
    <div style="flex:1">
      <label>Autor / Remitente</label>
      <input id="author" placeholder="Tu nombre..." />
    </div>
    <div style="width:120px">
      <label class="small">Mensaje ID</label>
      <div id="msgId" class="muted">1</div>
    </div>
  </div>

  <div class="fieldset">
    <label>CategorÃ­as (se guardan como cÃ³digos, ej. c4t/)</label>
    <div style="display:flex;flex-wrap:wrap;gap:8px;margin-top:6px">
      <label><input type="checkbox" data-code="c4t"/> Informe (c4t/)</label>
      <label><input type="checkbox" data-code="c5t"/> Idea (c5t/)</label>
      <label><input type="checkbox" data-code="c6t"/> Ayuda (c6t/)</label>
      <label><input type="checkbox" data-code="c7t"/> Importante (c7t/)</label>
      <label><input type="checkbox" data-code="c8t"/> InspiraciÃ³n (c8t/)</label>
    </div>
  </div>

  <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
    <label style="margin:0;flex:1">Inputs adicionales (activar para incluir en el archivo)</label>
    <label style="font-size:12px"><input id="toggleExtra" type="checkbox"/> Activar</label>
  </div>
  <div id="extraInputs" style="display:none;margin-top:8px">
    <label>Campo extra 1</label>
    <input id="extra1" placeholder="Meta / canal / proyecto" />
    <label style="margin-top:6px">Campo extra 2</label>
    <input id="extra2" placeholder="Etiqueta libre" />
  </div>

  <label style="margin-top:10px">Mensaje (hasta 20.000 caracteres). El primer carÃ¡cter guarda la hora/fecha</label>
  <textarea id="message" maxlength="20000" placeholder="Escribe aquÃ­... (Enter funciona normalmente)"></textarea>
  <div class="small muted">Caracteres: <span id="length">0</span> / 20000</div>

  <div class="controls">
    <button id="send">Compartir tu informaciÃ³n singular</button>
    <button id="repeat" class="secondary">Repetir Ãºltimo</button>
    <button id="download" class="secondary">Descargar bitÃ¡cora</button>
    <button id="clear" class="secondary">Nueva BitÃ¡cora</button>
  </div>

  <div class="meta">
    <div class="small">Estado: <span id="status">idle</span></div>
    <div class="small">Observador del frontend (opcional, selector): <input id="observerSelector" placeholder="ej. div.text-base" style="width:240px"/></div>
    <div class="small">BotÃ³n Inject (intenta colocar y enviar en la pÃ¡gina actual)</div>
    <div style="margin-top:8px"><button id="inject">Injectar e intentar enviar</button></div>
  </div>

  <div style="margin-top:10px">
    <strong>BitÃ¡cora (Ãºltimos 15 registros)</strong>
    <div id="log" class="log"></div>
  </div>
<script src="popup.js"></script>

</body>
</html>  // --- ARCHIVO popup.js
  // --- -------------------------------------

  // --- Simple storage using localStorage (append)
  const LS_KEY = 'pec_log_v1';
  const LS_COUNTER = 'pec_log_counter';

  function loadState(){
    const raw = localStorage.getItem(LS_KEY);
    const arr = raw ? JSON.parse(raw) : [];
    const counter = parseInt(localStorage.getItem(LS_COUNTER) || '1', 10);
    return {arr, counter};
  }
  function saveState(arr, counter){
    localStorage.setItem(LS_KEY, JSON.stringify(arr));
    localStorage.setItem(LS_COUNTER, ''+counter);
  }

  // --- UI refs
  const recipientEl = document.getElementById('recipient');
  const authorEl = document.getElementById('author');
  const msgIdEl = document.getElementById('msgId');
  const messageEl = document.getElementById('message');
  const lengthEl = document.getElementById('length');
  const sendBtn = document.getElementById('send');
  const repeatBtn = document.getElementById('repeat');
  const downloadBtn = document.getElementById('download');
  const clearBtn = document.getElementById('clear');
  const logEl = document.getElementById('log');
  const toggleExtra = document.getElementById('toggleExtra');
  const extraInputs = document.getElementById('extraInputs');
  const injectBtn = document.getElementById('inject');
  const statusEl = document.getElementById('status');
  const observerSelector = document.getElementById('observerSelector');

  // --- Init
  let state = loadState();
  let lastSent = null;
  updateUI();

  // --- helpers
  function fmtDate(d){
    return d.toLocaleString();
  }
  function getCheckedCategories(){
    const checked = [];
    document.querySelectorAll('.fieldset input[type=checkbox]').forEach(cb=>{
      if(cb.checked)checked.push(cb.dataset.code);
    });
    return checked.join('/');
  }

  function buildHeader(msgId){
    const recipient = recipientEl.value.trim() || 'DESTINATARIO_NO_DEFINIDO';
    const author = authorEl.value.trim() || 'AUTOR_NO_DEFINIDO';
    const now = new Date();
    const categories = getCheckedCategories();
    const extra1 = document.getElementById('extra1').value.trim();
    const extra2 = document.getElementById('extra2').value.trim();
    return `Nombre del destinatario del mensaje/canalizaciÃ³n: ${recipient}\n\n`+
           `Mensaje (incremento +${msgId}) de ${author} hora y fecha: ${fmtDate(now)}\n`+
           `Destinatario: ${recipient}\n`+
           `${categories?('Categorias:'+categories+'\n'):''}`+
           `${toggleExtra.checked ? `Extra1:${extra1} Extra2:${extra2}\n` : ''}`+
           `^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n`;
  }

  function buildFooter(){
    const now = new Date();
    const author = authorEl.value.trim() || 'AUTOR_NO_DEFINIDO';
    return `\n----------------------------------------------------------------------\nFIN DEL MENSAJE [x]-----------enviado ${fmtDate(now)} por ${author}\n`;
  }

  function appendLog(entry){
    state.arr.push(entry);
    state.counter = state.counter + 1;
    saveState(state.arr, state.counter);
    lastSent = entry;
    renderLog();
  }

  function renderLog(){
    msgIdEl.textContent = (state.counter || 1);
    logEl.innerHTML = '';
    const recent = state.arr.slice(-15).reverse();
    for(const e of recent){
      const div = document.createElement('div');
      div.style.padding='6px';
      div.style.borderBottom='1px solid #f0f0f0';
      div.innerHTML = `<div class="small muted">${e.header.replace(/\n/g,'<br>')}</div><pre style="white-space:pre-wrap">${e.body}</pre><div class="muted small">${e.footer.replace(/\n/g,'<br>')}</div>`;
      logEl.appendChild(div);
    }
  }

  // --- send flow
  function sendMessage(){
    const text = messageEl.value;
    if(!text.trim()){ alert('Mensaje vacÃ­o. Escribe algo.'); return; }
    const id = state.counter || 1;
    const header = buildHeader(id);
    const footer = buildFooter();
    const entry = {id, header, body: text, footer, ts: Date.now()};
    appendLog(entry);
    statusEl.textContent = 'enviando...';

    // Try to inject into page contentEditable/textarea and click send
    tryInjectToPage(text);

    // After appending, clear textarea for next fragment
    messageEl.value = '';
    lengthEl.textContent = '0';
    statusEl.textContent = 'esperando respuesta (observer si configurado)';
  }

  // --- repeat last
  function repeatLast(){
    if(!lastSent) return alert('No hay mensaje previo para repetir');
    // re-inject body
    tryInjectToPage(lastSent.body);
  }

  // --- inject function (best-effort)
  function tryInjectToPage(text){
    // Prefer contentEditable if present
    const editable = findEditable();
    if(editable){
      // If it's a textarea
      if(editable.tagName === 'TEXTAREA'){
        const ta = editable;
        const { selectionStart, selectionEnd } = ta;
        ta.value = text;
        ta.selectionStart = ta.selectionEnd = ta.value.length;
        ta.dispatchEvent(new Event('input', {bubbles:true}));
      } else if(editable.isContentEditable){
        // set text inside
        // replace innerHTML with escaped text inside a <div>
        editable.focus();
        // for safety, try to insert plain text preserving newlines
        const lines = text.split('\n');
        editable.innerHTML = '';
        for(let i=0;i<lines.length;i++){
          const span = document.createElement('div');
          span.textContent = lines[i];
          editable.appendChild(span);
        }
        // dispatch input
        editable.dispatchEvent(new InputEvent('input', {bubbles:true}));
      }

      // find send button dynamically
      const sendBtn = findSendButton();
      if(sendBtn){
        // small delay to let React reconcile
        setTimeout(()=>{
          try{ sendBtn.click(); statusEl.textContent='mensaje enviado (click)'; }catch(e){ console.warn(e); statusEl.textContent='error click'; }
        }, 120);
      } else {
        // fallback: copy to clipboard and inform user
        navigator.clipboard.writeText(text).then(()=>{
          alert('Texto copiado al portapapeles. Pega manualmente en el editor y envÃ­a.');
          statusEl.textContent='copiado al portapapeles (fallback)';
        }).catch(()=>{
          alert('No se pudo inyectar ni copiar. No hay editor detectable.');
        });
      }
    } else {
      alert('No se detectÃ³ editor en la pÃ¡gina. Puedes pegar manualmente.');
    }
  }

  function findEditable(){
    // heurÃ­sticos: contentEditable div, or visible textarea
    const ta = document.querySelector('textarea:not([style*="display: none"]), textarea:not([hidden])');
    if(ta && ta.offsetParent !== null) return ta;
    const editable = document.querySelector('[contenteditable="true"]');
    if(editable) return editable;
    // try more generic
    const ed2 = Array.from(document.querySelectorAll('[contenteditable]')).find(e=>e.getAttribute('contenteditable')!=='false');
    if(ed2) return ed2;
    return null;
  }

  function findSendButton(){
    // try common selectors; best-effort
    return document.querySelector('#composer-submit-button') || document.querySelector('button[data-testid="send-button"]') || document.querySelector('button[aria-label*="Enviar"], button[aria-label*="Send"]');
  }

  // --- download log
  function downloadLog(){
    const content = state.arr.map(e=>e.header+e.body+e.footer).join('\n\n-----\n\n');
    const blob = new Blob([content], {type:'text/plain;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = `bitacora_${(new Date()).toISOString().replace(/[:.]/g,'-')}.txt`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  // --- new bitacora
  function clearLog(){
    if(!confirm('Crear nueva bitÃ¡cora y borrar la actual?')) return;
    state.arr = [];
    state.counter = 1;
    saveState(state.arr, state.counter);
    renderLog();
  }

  // --- toggle extra inputs
  toggleExtra.addEventListener('change', ()=>{
    extraInputs.style.display = toggleExtra.checked ? 'block' : 'none';
  });

  messageEl.addEventListener('input', ()=>{
    lengthEl.textContent = messageEl.value.length;
  }, {passive:true});

  // --- first char time capture
  let firstCharCaptured = false;
  messageEl.addEventListener('keydown', (e)=>{
    if(!firstCharCaptured && e.key.length===1){
      // first printable char pressed
      firstCharCaptured = true;
      const now = new Date();
      // prepend header visually in a small note (not in textarea)
      console.log('Primer caracter detectado a las', now.toLocaleString());
      statusEl.textContent = 'primer caracter: '+now.toLocaleString();
    }
  });

  // attach controls
  sendBtn.addEventListener('click', sendMessage);
  repeatBtn.addEventListener('click', repeatLast);
  downloadBtn.addEventListener('click', downloadLog);
  clearBtn.addEventListener('click', clearLog);

  injectBtn.addEventListener('click', ()=>{
    const text = messageEl.value || (lastSent && lastSent.body) || '';
    if(!text) return alert('Nada para inyectar');
    tryInjectToPage(text);
  });

  // --- observer optional watch on target selector
  let observer = null;
  document.getElementById('observerSelector').addEventListener('change', ()=>{
    const sel = observerSelector.value.trim();
    if(observer){ observer.disconnect(); observer = null; statusEl.textContent='observer detenido'; }
    if(sel){
      const el = document.querySelector(sel);
      if(!el) return alert('Selector no encontrado en esta pÃ¡gina');
      observer = new MutationObserver((muts)=>{
        statusEl.textContent = 'Cambio detectado en target: '+new Date().toLocaleTimeString();
        // Cuando cambia el DOM, habilitar botÃ³n de envÃ­o del popup
        sendBtn.disabled = false;
      });
      observer.observe(el, {childList:true, subtree:true, characterData:true});
      statusEl.textContent='observer activo en '+sel;
    }
  });

  // --- init state
  (function init(){
    if(!state.arr) state.arr = [];
    if(!state.counter) state.counter = 1;
    renderLog();
  })();
